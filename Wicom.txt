#include <Arduino.h>
#include "painlessMesh.h"
#include <WiFi.h>
//#include <AsyncTCP.h>
#include <SPIFFS.h>
//#include <ESP32WebServer.h>
#include <ESPmDNS.h>
#include <ESPAsyncWebServer.h>
#include <AsyncElegantOTA.h>
#include <RBD_Timer.h>
#include "IPAddress.h"
#include <SoftwareSerial.h>
#include <EEPROM.h>
#include <Arduino_JSON.h>
#include <SoftwareSerial.h>

AsyncWebServer server(80);
String ssid_1 = "gas",password_1 = "password";
char buff1[30];
char buff2[60];
// REPLACE WITH YOUR NETWORK CREDENTIALS
const char* ssid = "gasoline_Board1";
const char* password = "gasoline";
// REPLACE WITH YOUR WEBPAGE LOGIN CREDENTIALS
const char* http_username = "aditya";
const char* http_password = "adi12345";
// REPLACE WITH YOUR OTA CODE UPDATER CREDENTIALS CREDENTIALS
const char* OTA_username = "gasoline";
const char* OTA_password = "gasoline123";

const char* Bright = "value";
const char* led_status = "led_status";
const char* intermediator_status = "intermediator_status";    //run

const char* Company_name = "Company_name";
const char* Trade_name = "Trade_name";
const char* City = "City";
const char* State = "State";
const char* Mobile_number = "Mobile_number";    //personal

const char* Fuel_dispenser = "Fuel_dispenser";
const char* Site_number = "Site_number";
const char* Serial_number = "Serial_number";
const char* Num_of_groups = "Num_of_groups";
const char* Group_type = "Group_type";   //site_information

const char* Flashing = "Flashing";
const char* Flash_time = "Flash_time";
const char* Flash_style = "Flash_style";
const char* Con_cash = "Con_cash";
const char* Con_debit = "Con_debit";
const char* Con_credit = "Con_credit";   //cdc_information

const char *Price_grade1 = "Price_grade1"; // grade price information
const char *Price_grade2 = "Price_grade2";
const char *Price_grade3 = "Price_grade3";
const char *Price_grade4 = "Price_grade4";
const char *Price_grade5 = "Price_grade5";
const char *Price_grade6 = "Price_grade6";
const char *Price_grade7 = "Price_grade7";
const char *Price_grade8 = "Price_grade8";
const char *Price_grade9 = "Price_grade9";
const char *Price_grade10 = "Price_grade10";
const char *Price_grade11 = "Price_grade11";
const char *Price_grade12 = "Price_grade12";


int POS_setup_enable = 3; 
//============================================== json setup ==========================================//
// compute the required size
//const size_t CAPACITY = JSON_ARRAY_SIZE1(12) + 12*JSON_OBJECT_SIZE1(2) + JSON_OBJECT_SIZE1(15);


// allocate the memory for the document
StaticJsonDocument<5000> doc;

String adity = "";

// Set your Static IP address
IPAddress local_IP(222, 168, 43, 148);
// Set your Gateway IP address
IPAddress gateway(192, 168, 1, 1);
IPAddress subnet(255, 255, 0, 0);
IPAddress primaryDNS(8, 8, 8, 8);   //optional
IPAddress secondaryDNS(8, 8, 4, 4); //optional

unsigned long previousMillis = 0;
unsigned long interval = 30000;

//------------------------mesh setup--------------------------------
#define MESH_PREFIX meshssid
#define MESH_PASSWORD meshpassword
#define MESH_PORT meshport
Scheduler userScheduler; // to control your personal task
painlessMesh mesh;


String meshssid = "GAP"; //  Mesh name
char essid[20];
String glob7;

String meshpassword = "12345678"; //  Mesh Password
char epass[20];
String glob8;

int16_t meshport = 1134; //  Mesh Port

void sendMessage(); // Prototype so PlatformIO doesn't complain
void showNodeList();
void receivedCallback(uint32_t from, String &msg);
void newConnectionCallback(uint32_t nodeId);
void droppedConnectionCallback(uint32_t nodeId);
void changedConnectionCallback();
void nodeTimeAdjustedCallback(int32_t offset);
void delayReceivedCallback(uint32_t from, int32_t delay);

Task taskSendMessage(TASK_SECOND * 1, TASK_FOREVER, &sendMessage);

void sendMessage() {} ;

uint32_t nodeId_array[20] = {0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0};
uint32_t live_nodeId_array[20] = {0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0};
uint32_t setup_node_id_mac=0;

bool calc_delay = false;
SimpleList<uint32_t> nodes;
uint32_t nsent=0;
char buff[512];
int connected_node_size = 0,old_node_size = 0;

//--------------------------TEST
int led_status_send=0;
//unsigned long previousMillis = 0;        // will store last time LED was updated
unsigned long OnTime = 10000,send_times = 0;           // milliseconds of on-time
int node,times_rec =0;

String readings;
String getReadings () {
  JSONVar jsonReadings;
  jsonReadings["node"] = 1;
  jsonReadings["temp"] = 2;
  jsonReadings["times"] = 1010;
  jsonReadings["led_status"] = 1;
  readings = JSON.stringify(jsonReadings);
  return readings;
}



// setting PWM properties for slider
const int freq = 490;
const int ledChannel = 0,cashled = 1,creditled = 2, debitled = 3,led_full_off = 0, led_full_on = 255;
const int resolution = 8;
unsigned long int led_blink_time_on=0;
unsigned long currentMillis,blinkStartMillis,blinkPeriod = 200;
bool brightness_update =false,price_update =true,price_change =true,setting_update=false,password_reset =false;
int yourInputInt,Brightness,led_send_count = 10,grade_check = 0;
int price_digit1,price_digit2,price_digit3,price_digit4,price_digit5,price_digit6,price_digit7,price_digit8,price_digit9;
int price_digit10,price_digit11,price_digit12,price_digit13,price_digit14,price_digit15,price_digit16,price_digit17,price_digit18;
int price_digit19,price_digit20,price_digit21,price_digit22,price_digit23,price_digit24,price_digit25,price_digit26,price_digit27;
int price_digit28,price_digit29,price_digit30,price_digit31,price_digit32,price_digit33,price_digit34,price_digit35,price_digit36;
int price_digit37,price_digit38,price_digit39,price_digit40,price_digit41,price_digit42,price_digit43,price_digit44,price_digit45,price_digit46,price_digit47,price_digit48;
int num_of_groups = 6,fuel_dispenser=0 , master_RF_channel_num ,secondary_RF_channel_num;
int idx[19] = {},idy[19] = {};
long int serial_number,site_number;
bool led_blink = 0,intermediator=0,group_type=0,led_blink_status = 0,stop_blink = true,CDC_update=1,cashdebitcredit=0;
String state="ahm",company_name="gasoline",trade_name="boards",city="NY",site_address="NY",zip_code="123",site_serial_number="",mobile_number="",customer_name="",email="";
String create_pin1="",create_pin2="",retrieve_name="",retrieve_mobile_number="",retrieve_email="",retrieve_company="";
String master_pin="12345678",master_pin_check="",old_pin="",updated_pin1="",updated_pin2="",login_pin="";
String wifi_setup_board_name="",wifi_setup_ssid="",wifi_setup_password="",wifi_setup_port_number="",wifi_setup_channel_number="";
int wifi_setup_num_of_groups =0,MASTER_channel_RF = 3,SECONDARY_channel_RF = 4;
float price_grade1, price_grade2, price_grade3, price_grade4, price_grade5, price_grade6, price_grade7, price_grade8, price_grade9, price_grade10, price_grade11, price_grade12,price_grade13,price_grade14,price_grade15,price_grade16;
int dec_price_grade1, dec_price_grade2, dec_price_grade3,dec_price_grade4,dec_price_grade5,dec_price_grade6,dec_price_grade7,dec_price_grade8,dec_price_grade9,dec_price_grade10,dec_price_grade11,dec_price_grade12,dec_price_grade13,dec_price_grade14,dec_price_grade15,dec_price_grade16;
bool price_grade_1_update= true,price_grade_2_update = true,price_grade_3_update= true,price_grade_4_update= true,price_grade_5_update= true,price_grade_6_update= true,price_grade_7_update= true,price_grade_8_update = true;
bool price_grade_9_update= true,price_grade_10_update= true,price_grade_11_update= true,price_grade_12_update= true,price_grade_13_update= true,price_grade_14_update = true,price_grade_15_update= true,price_grade_16_update = true;
//=================================== cdc variable =============================================//
int flash_time = 6,flash_style = 1;
bool flashing = 0, con_cash = 0, con_debit = 0, con_credit = 0,cdc_RF_update = false,Advanced_RF_update = false, rf_price_transmit = false;
//======================================== Arrduino Variable==========================================//
int dataPin = 25;  // used for data shift register
int latchPin = 27;
int clockPin = 26;
#define CASH 22
#define DEBIT 22
#define CREDIT 22
//======================================================================================================//
String sliderValue = "0"; //for slider
byte dec_digits[12] = {0b1000000, 0b1111001, 0b0100100, 0b0110000, 0b0011001, 0b0010010, 0b0000010, 0b1111000, 0b0000000, 0b0010000, 0b1111111, 0b10111111};
//==================================== Intermediator variable =========================================//
int setHC = 12; // used for setting for HC-12   //12
#define RXD2 14 //16  //14  //connect inverse TX of rf into RXD
#define TXD2 27 //17  //27  ////connect inverse RX of rf into TXD
#define RESEND_POS 35 //to resend data of grades
#define RED_LED_POS 23 
#define WHITE_LED_POS 22 
#define BLUE_LED_POS 25

bool delayRunning; // true if still waiting for delay to finish
unsigned long delayStart = 0; // the time the delay started
bool intermediator_price_update =false,SLEEP_MODE = false; //
int bright_range=4;
hw_timer_t * timer = NULL;
int Gillbarco_setup = 0,Grade_control_setup = 0, Channel_control_setup = 0;
//--------------- GRADE ORDER VARIABLES ----------//
int G_NUM_ALLOC[8] = {1,2,3,4,5,6,7,8};
int Master_sec_board = 0;
int Max_grade_env = 4;
//-----------------------Digits ints POS------------------------------
int digitqty = 0;
int currentpos = 0;
bool giilbarco_data_rec = false;
SoftwareSerial GILL_VER_SERIAL(16, 17); //Rx , Tx Serial input HMI COMMUNICATION
int GILL_VER_digitval[48] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
int GILL_VER_digitvalold[48] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
int digitval[48] = {1, 0, 1, 1, 0, 2, 1, 0, 3, 1, 0, 4, 1, 0, 5, 1, 0, 6, 1, 0, 7, 1, 0, 8, 1, 0, 9, 1, 1, 0, 1,1,1,1,1,2};
int digitvalold[48] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
//-----------------------Timer ints POS------------------------------
HMI::COMMUNICATION hmi;   // hmi class definition
RBD::Timer timerupdate;
//RBD::Timer timerreset;
//RBD::Timer timerbut;
RBD::Timer resettimer2;
RBD::Timer hmitimer;
RBD::Timer gill_update;
//-------------------------- Example 3 - Receive with start- and end-markers POS --------------------//

const byte numChars = 13;
char receivedChars[numChars];
char receivedChars2[numChars];
bool newData = false;
bool inite = true;

bool recvInProgress = false;
bool recvInProgress2 = false;
byte ndx = 0;
char startMarker = 2;
char endMarker = 3;
char ack = 6;
char nak = 15;
char rc;
char lrc;
char lrc2;
byte xorTemp;
char got0;

bool waitingforlrc = false;
//------------------------- HMI INTERFACE ---------------------------//
byte cmd[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; //0xFF 0x02 0x00 0x00 0x00 0x00 0x00 0xFF    
int hmicount =0,page_id=0,wifi_font=0,device_flash=0;         
char __CMD_HEAD[1] = {0xAA};
char __CMD_TAIL[4] = {0xCC, 0x33, 0xC3, 0x3C};
unsigned char data[18]={0,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9};
unsigned short data_value[48] = {0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0};
unsigned char hmi_price_digit[96],hmi_price_digit_g[96],hmi_sleep_digit[96];
unsigned char hmi_data_recieve[56] ;
unsigned char BLANK[5] = {0X20, 0X00};
unsigned char SELECTED[10] = {0X53,0X45,0X4C,0X45,0X43,0X54,0X45,0X44, 0X00};
unsigned char SINGLE[10] = {0X53,0X49,0X4E,0X47,0X4C,0X45, 0X00};
unsigned char DUAL[10] = {0X44,0X55,0X41,0X4C, 0X00};
unsigned char MASTER[10] = {0X4D,0X41,0X53,0X54,0X45,0X52,0X00};
unsigned char SECONDARY[20] = {0X53,0X45,0X43,0X4F,0X4E,0X44,0X41,0X52,0X59,0X00};
unsigned char SUCCESSFULL[20] = {0X53,0X55, 0X43, 0X43, 0X45, 0X53 ,0X53, 0X46, 0X55, 0X4C, 0X4C, 0X00};
unsigned char WRONG_PIN[20] = {0X57, 0X52, 0X4F, 0X4E, 0X47, 0X20, 0X50, 0X49, 0X4E, 0X00};
unsigned char CDC_LEVEL_1[50] = {0X4F,0X50,0X54,0X20,0X31,0X29,0X20,0X4C, 0X31, 0X2D, 0X20, 0X43, 0X41, 0X53, 0X48, 0X20, 0X7C, 0X20, 0X4C, 0X32, 0X2D, 0X20, 0X44, 0X45, 0X42, 0X49, 0X54, 0X2F, 0X43, 0X52, 0X45, 0X44, 0X49, 0X54};
unsigned char CDC_LEVEL_2[50] = {0X4F,0X50,0X54,0X20,0X32,0X29,0X20,0X4C, 0X31, 0X2D, 0X20, 0X43, 0X41, 0X53, 0X48, 0X20, 0X7C, 0X20, 0X4C, 0X32, 0X2D, 0X20, 0X43, 0X52, 0X45, 0X44, 0X49, 0X54};
unsigned char CDC_LEVEL_3[50] = {0X4F,0X50,0X54,0X20,0X33,0X29,0X20,0X4C, 0X31, 0X2D, 0X20, 0X43, 0X41, 0X53, 0X48, 0X2F,  0X44, 0X45, 0X42, 0X49, 0X54, 0X20, 0X7C, 0X20, 0X4C, 0X32, 0X2D, 0X20, 0X43, 0X52, 0X45, 0X44, 0X49, 0X54};
unsigned char CDC_LEVEL_4[50] = {0X4F,0X50,0X54,0X20,0X34,0X29,0X20,0X4C, 0X31, 0X2D, 0X4D, 0X45, 0X4D, 0X42, 0X45, 0X52, 0X20, 0X50, 0X52, 0X49, 0X43, 0X45,0X20, 0X7C, 0X20, 0X4C, 0X32, 0X2D, 0X4E, 0X4F, 0X4E, 0X20,0X4D, 0X45, 0X4D, 0X42, 0X45, 0X52, 0X20, 0X50, 0X52, 0X49, 0X43, 0X45,};
unsigned char CDC_LEVEL_5[50] = {0X4F,0X50,0X54,0X20,0X35,0X29,0X20,0X4C, 0X31, 0X2D, 0X20, 0X4D, 0X45, 0X4D, 0X42, 0X45, 0X52, 0X20, 0X7C, 0X20, 0X4C, 0X32, 0X2D, 0X20, 0X4E, 0X4F, 0X4E, 0X20,0X4D, 0X45, 0X4D, 0X42, 0X45, 0X52};
unsigned char WAIT[30] = {0X57,0X41,0X49,0X54,0X00};
unsigned char DONE[30] = {0X44,0X4F,0X4E,0X45, 0X00};
unsigned char SENT[30] = {0X53,0X45,0X4E,0X54, 0X00};
unsigned char ON[10] = {0X4F,0X4E, 0X00};
unsigned char OFF[10] = {0X4F,0X46,0X46, 0X00};
unsigned long hmi_address;
unsigned char data_length, data_num,data_st_byte;
unsigned short touch_data;
bool hmi_serial_recieved = false,hmi_cash_price = false,hmi_credit_price = false;
unsigned char G_CASH_ID[8]={16,17,18,19,20,21,81,81};
unsigned char G_CREDIT_ID[8]={22,23,24,25,26,27,82,82};
unsigned char WIFI_GRADE_SET_ID[4]={52,53,54,55};
unsigned char WIFI_SETUP_BOARD_GRADE_SELECT[6]={0,0,0,0,0,0};
static String inputString,inputString_ascii,nodeid_mac,const_cash = "_cash",const_credit = "_credit",disp_g_name;
String G1_NAME="",G2_NAME="",G3_NAME="",G4_NAME="",G5_NAME="",G6_NAME="";
String G7_NAME="",G8_NAME="",G9_NAME="",G10_NAME="",G11_NAME="",G12_NAME="";
String G13_NAME="",G14_NAME="",G15_NAME="",G16_NAME="";
String G_NAME[16] = {"","","","","","","","","","","","","","","",""};
int string__length = 0,Retrieve_count = 0,nodesize=0,nodeid_mac__length,disp_g_name_length,MAXnodesize=0,LIVEnodesize=0;
int nodeid_mac_num[20] = {0x00000A00,0x00000A80,0x00000B00,0x00000B80,0x00000C00,0x00000C80,0x00000D00,0x00000D80,0x00000E00,0x00000E80,0x00000F00,0x00000F80};
int disp_g_name_num[20] = {0x00001A00,0x00001A80,0x00001B00,0x00001B80,0x00001C00,0x00001C80,0x00001D00,0x00001D80,0x00001E00,0x00001E80,0x00001F00,0x00001F80,0x00003000,0x00003080,0x00003100,0x00003180};
char passbuf[20],nodeid_buff[20],disp_g_name_buff[20];
unsigned char passwordbuf[20],nodeidbuffer[20],disp_gbuffer[20];
unsigned long hmi_pin;
#define RXD3 18  //HMI HARDWARE RXD
#define TXD3 5 //HMI HARDWARE TXD
//-----------------------Gilbarco ints POS ------------------------------


byte ACK = 134;
byte START  = 130;
byte STOP = 131;
byte PRICE = 202;
byte CHK = 15;
byte DATA = 11;

int price[5];     //-------- To receive 6 numbers at a time from windows APP via Serial Communication
int digit = 0;        //------ to store the number for a digit
int category = 0;         //------ used for Product selection
bool inProcess = false;
bool newPrice = false;
bool readyToSend = false;
bool sending = false;
bool sss = false;

char buffer[16];
// =========================== variables copy =========================================//
//---------------------- Digit Setup---------------
int resetssidpin = 21; //4//21 // // used to reset the SSID and PASSWORD to Default


int input;
//int cmd;
int value;

int SUM;
int SUMout;
int checkSUM;
bool gotsum = false;
bool usesum = false;

bool memupdate = false;

byte maxdigits = 45;
byte digitcount = 3; // 0 for 3 digits, 1 for 4 digits, 2 for 5 digits, 3 for 6 digits
byte glob2;

//byte digitval[45] = {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
//                     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};
int digitvalTEST[45] = {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};
byte glob0[45];

// byte digitpos = 0;
byte glob3;
byte masterslave = 0;
byte glob4;
byte DRRB = 0;
byte glob5;
byte fontstyle = 0;
byte glob6;
byte maxbrightness = 9;

byte error = 0; // errors like current finding seg missing
// bool flash = false;
bool remoteflash = false;

byte brightness = 34;
byte glob1;
byte glob82;
byte glob87;
byte glob88;
bool autobright = true;
byte AUTO_BRIGHT;
byte rledpin;
byte gledpin;
byte bledpin;
bool flashone = false;
int resetcount = 0;
//---------------------------------------------------------set address
int dipadd[] = {19, 21};
int transAddress;
int channel;
int fmaxbrightness;
int16_t newbrightness;

int brighttrans[5] = {0, 7, 15, 23, 34};
//--------------------------------------------------------set digit position
int dipPos[] = {4, 16, 13, 26, 25};
int digitpos = 0;
bool flash = false;

//--------------------------------- modes ------------------------------//
bool wifi_mode = true, rf_mode = true,gilbarco_mode = true,verifone_mode = true; 
//-------------------------- Timer Setup -------------------------------

RBD::Timer timerresetssid;
RBD::Timer timerbut; //---------------This timer is for the button delay
RBD::Timer timersen;
RBD::Timer timerincoming;
RBD::Timer timerreset;
RBD::Timer timerreset2;
RBD::Timer timerrecount;
RBD::Timer timerv5;
RBD::Timer flash_timer;

void notFound(AsyncWebServerRequest *request) {
  request->send(404, "text/plain", "Not found");
}

String readFile(fs::FS &fs, const char * path){
  Serial.printf("Reading file: %s\r\n", path);
  File file = fs.open(path, "r");
  if(!file || file.isDirectory()){
    Serial.println("- empty file or failed to open file");
    return String();
  }
  Serial.println("- read from file:");
  String fileContent;
  while(file.available()){
    fileContent+=String((char)file.read());
  }
  Serial.println(fileContent);
  return fileContent;
}

void writeFile(fs::FS &fs, const char * path, const char * message){
  Serial.printf("Writing file: %s\r\n", path);
  File file = fs.open(path, "w");
  if(!file){
    Serial.println("- failed to open file for writing");
    return;
  }
  if(file.print(message)){
    Serial.println("- file written");
  } else {
    Serial.println("- write failed");
  }
}


void iport_r() {


  delay(40);
  digitalWrite(setHC, 0); // enter AT command mode
  delay(80);
  switch (SECONDARY_channel_RF) //#transAddress//recievedata_RF_channel
  {
    case 0:
      Serial2.print(F("AT+C005")); // set to channel 5
      break;
    case 1:
      Serial2.print(F("AT+C010")); // set to channel 10
      break;
    case 2:
      Serial2.print(F("AT+C020")); // set to channel 20
      break;
    case 3:
      Serial2.print(F("AT+C030")); // set to channel 30
      break;
    case 4:
      Serial2.print(F("AT+C035")); // set to channel 30
      break;
    case 5:
      Serial2.print(F("AT+C040")); // set to channel 30
      break;
    case 6:
      Serial2.print(F("AT+C045")); // set to channel 30
      break;
    case 7:
      Serial2.print(F("AT+C050")); // set to channel 30
      break;
    case 8:
      Serial2.print(F("AT+C055")); // set to channel 30
      break;
    case 9:
      Serial2.print(F("AT+C060")); // set to channel 30
      break;
    case 10:
      Serial2.print(F("AT+C065")); // set to channel 30
      break;
    case 11:
      Serial2.print(F("AT+C070")); // set to channel 30
      break;
    case 12:
      Serial2.print(F("AT+C075")); // set to channel 30
      break;
    case 13:
      Serial2.print(F("AT+C080")); // set to channel 30
      break;
    case 14:
      Serial2.print(F("AT+C085")); // set to channel 30
      break;
    case 15:
      Serial2.print(F("AT+C090")); // set to channel 30
      break;
    case 16:
      Serial2.print(F("AT+C095")); // set to channel 30
      break;
    case 17:
      Serial2.print(F("AT+C0100")); // set to channel 30
      break;
  }
  delay(80);
  digitalWrite(setHC, 1); // enter transparent mode
  String input1 = Serial2.readString();
  Serial.println(input1);
  delay(40);
}


void iport_s() {

  delay(40);
  digitalWrite(setHC, 0); // enter AT command mode
  delay(80);

  switch (MASTER_channel_RF) {
    case 0:
      Serial2.print(F("AT+C005")); // set to channel 5
      break;
    case 1:
      Serial2.print(F("AT+C010")); // set to channel 10
      break;
    case 2:
      Serial2.print(F("AT+C020")); // set to channel 20
      break;
    case 3:
      Serial2.print(F("AT+C030")); // set to channel 30
      break;
    case 4:
      Serial2.print(F("AT+C035")); // set to channel 30
      break;
    case 5:
      Serial2.print(F("AT+C040")); // set to channel 30
      break;
    case 6:
      Serial2.print(F("AT+C045")); // set to channel 30
      break;
    case 7:
      Serial2.print(F("AT+C050")); // set to channel 30
      break;
    case 8:
      Serial2.print(F("AT+C055")); // set to channel 30
      break;
    case 9:
      Serial2.print(F("AT+C060")); // set to channel 30
      break;
    case 10:
      Serial2.print(F("AT+C065")); // set to channel 30
      break;
    case 11:
      Serial2.print(F("AT+C070")); // set to channel 30
      break;
    case 12:
      Serial2.print(F("AT+C075")); // set to channel 30
      break;
    case 13:
      Serial2.print(F("AT+C080")); // set to channel 30
      break;
    case 14:
      Serial2.print(F("AT+C085")); // set to channel 30
      break;
    case 15:
      Serial2.print(F("AT+C090")); // set to channel 30
      break;
    case 16:
      Serial2.print(F("AT+C095")); // set to channel 30
      break;
    case 17:
      Serial2.print(F("AT+C0100")); // set to channel 30
      break;
  }
  
  delay(80);
  digitalWrite(setHC, 1); // enter transparent mode
  String input1 = Serial2.readString();
  Serial.println(input1);
  delay(40);
}
void RESET_DEVICES()
{
  
  iport_s();
  Serial2.println(8002);// for master
  Serial2.println(8001);// for secondary
  delay(100);
  Serial.println("SENT RESET TO ALL DEVICES ===========================");
  delay(60);
}
void getsensordata()
{

  if (masterslave == 1 && timerincoming.isExpired())
  {
    //  Read the Values
    //TEMP//light1();
    delay(10);
    //    temp1();
    //    delay(10);
    //    delay(10);

    Serial.print("brightness is ");
    //TEMP//Serial.println(bright);
    //    Serial.print("Temp is ");
    //    Serial.println(templvl);

    // delay(20);

    //    int bvmin = min(bright, templvl);
    //
    //    Serial.print("The min Value is ");
    //    Serial.println(bvmin);
      //TEMP//
      /*
     if (bright != glob82 && autobright == true)
    {
      glob82 = bright;
      brightness = bright;
      //TEMP//setBrightness(brightness);

      EEPROM.put(80, brightness);
      EEPROM.commit();
      Serial.println("Brightness into mem");
      //TEMP//setBrightness(brightness);

      Serial.println(" SENDING BRIGHTNESS ");
      Serial.println(" brightness is = " + brightness);
      String br = "BRIGHTNESS," + String(brightness) + ",";
      mesh.sendBroadcast(br);
      taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
    }

    //    byte fontglob;
    //    if (fontglob != fontstyle) {
    //      fontglob = fontstyle;
    //      Serial.println(" SENDING FONT STYLE ");
    //      String fs = "FONT," + String(fontstyle) + ",";
    //      mesh.sendBroadcast(fs);
    //    }

    String sync;
    for (int i = 0; i < 36; i++)
    {
      sync += digits[i] + "," + String(digitval[i]) + ",";
      yield();
    }
    Serial.println(sync);
    mesh.sendBroadcast(sync);
    taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
  */
    //TEMP//updateShiftRegister(); // Update Everyone
  }
}
//------------------------------------------MESH SETUP---------------------------------

String getStringPartByNr(String data, char separator, int index)
{
  // spliting a string and return the part nr index split by separator
  int stringData = 0;   // variable to count data part nr
  String dataPart = ""; // variable to hole the return text
  for (int i = 0; i < data.length() - 1; i++)
  { // Walk through the text one letter at a time
    if (data[i] == separator)
    {
      // Count the number of times separator character appears in the text
      stringData++;
    }
    else if (stringData == index)
    {                           // get the text when separator is the rignt one
      dataPart.concat(data[i]); // strcat(result, &data[i]); better for embedded...
    }
    else if (stringData >= index)
    { // return text and stop if the next separator appears - to save CPU-time
      return dataPart;
      break;
    }
  }
  return dataPart; // return text if this is the last part
}

String digits[] = {"D01", "D02", "D03", "D04", "D05", "D06", "D07", "D08", "D09", "D10", "D11", "D12", "D13", "D14", "D15",
                   "D16", "D17", "D18", "D19", "D20", "D21", "D22", "D23", "D24", "D25", "D26", "D27", "D28", "D29", "D30",
                   "D31", "D32", "D33", "D34", "D35", "D36", "D37", "D38", "D39", "D40", "D41", "D42", "D43", "D44", "D45"};

//------------------------------------------- If we Recieve anything, USE IT HERE ---------------------------
/*
void sendMessage() {
String msg = getReadings();
String sync;
    for (int i = 0; i < 36; i++)//45
    {
      sync += digits[i] + "," + String(digitval[i]) + ",";
      yield();
    }
    Serial.print("sending sync = ");
    Serial.println(sync);

    String br = "BRIGHTNESS," + String(brightness) + ",";
    Serial.print("sending BRIGHTNESS = ");
    Serial.println(br);
    mesh.sendBroadcast( sync );

 // msg += mesh.getNodeId();
  //Serial.print("sending msg = ");
  //Serial.println(msg);
  //mesh.sendBroadcast( msg );
  //taskSendMessage.setInterval( random( TASK_SECOND * 1, TASK_SECOND * 5 ));
}*/
void receivedCallback(uint32_t from, String &msg)
{
  Serial.printf("Receiving: Received from %u msg=%s\n", from, msg.c_str());
  timerincoming.restart();
  Serial.println(" GOT data from mesh connections ");
/*
  for (int i = 0; i < msg.length() - 1; i++)
  {

    //-----------------------------------------------For digit information Recieving -------------------------------

    String pass = getStringPartByNr(msg, ',', i);
    // look for "01" / "02" / "03"
    for (int j = 0; j < 36; j++)
    {
      if (pass == digits[j])
      {
        Serial.println(" GOT digits = " + String(digits[j]));
        digitval[j] = (getStringPartByNr(msg, ',', i + 1)).toInt(); //  Goes to the next idx position and saves it to Digitval

        if (digitval[j] != glob0[j])
        {

          EEPROM.put(j, digitval[j]);
          EEPROM.commit();
          // Serial.println("Digit into mem");

          for (int p = 0; p <= digitcount; p++)
          {
            if (j == digitpos + p)
            {
              //TEMP//updateShiftRegister();
              glob0[j] = digitval[j];
              // Serial.println("UPDATING NOW");
            }
          }

          if (masterslave == 1 && DRRB == 0)
          {
            String sync;
            sync += digits[j] + "," + String(digitval[j]) + ",";
            Serial.println(sync);
            mesh.sendBroadcast(sync);
            taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
            Serial.println("sync MSG SENDING FROM GOT DIGITS");
          }

          glob0[j] = digitval[j];
        }
        Serial.println(digitval[j]);
      }
      yield();
    }

    //-----------------------------  For Brightness,  Looks for 80 then the next 2 number as Value for Brightness ---------------

    if ((getStringPartByNr(msg, ',', i) == "BRIGHTNESS"))
    { //---------------  looking for [BRIGHTNESS]  then [0-34]-----------
      Serial.println(F("got Brightness"));
      brightness = (getStringPartByNr(msg, ',', i + 1)).toInt();

      if (brightness != glob1)
      {
        glob1 = brightness;
        EEPROM.put(80, brightness);
        EEPROM.commit();
        Serial.println("Brightness into mem");
      }
      //TEMP//setBrightness(brightness);
    }

    //-----------------------------  For  Auto Brightness on and off ---------------

    if ((getStringPartByNr(msg, ',', i) == "AUTOBRIGHTNESS"))
    { //---------------  looking for [AUTOBRIGHTNESS]  then [0-1]-----------
      Serial.println(F("got Auto Brightness"));
      AUTO_BRIGHT = (getStringPartByNr(msg, ',', i + 1)).toInt();

      if (AUTO_BRIGHT != glob87)
      {
        glob87 = AUTO_BRIGHT;
        EEPROM.put(87, AUTO_BRIGHT);
        EEPROM.commit();
        Serial.println("Brightness into mem");
      }
      if (AUTO_BRIGHT == 0)
      {
        autobright = true;
      }
      else
      {
        autobright = false;
      }
      Serial.println(AUTO_BRIGHT);
    }

    //-----------------------------  For  MAX Brightness LEVEL ---------------

    if ((getStringPartByNr(msg, ',', i) == "AUTOBRIGHTNESSMAX"))
    { //---------------  looking for [AUTOBRIGHTNESS]  then [1-9]-----------
      Serial.println(F("got Auto Brightness"));
      maxbrightness = (getStringPartByNr(msg, ',', i + 1)).toInt();

      if (maxbrightness != glob88)
      {
        glob88 = maxbrightness;
        EEPROM.put(88, maxbrightness);
        EEPROM.commit();
        Serial.println("MAXBrightness into mem");
      }

      Serial.println(maxbrightness);
    }

    //-----------------------------  For Digit count Setting ---------------------------------------------------------------------

    if ((getStringPartByNr(msg, ',', i) == "DIGITCOUNT"))
    { //---------------  looking for [DIGITCOUNT]  then  [1,3,4,5,6]-----------
      Serial.println(F("got new Digit Count"));
      digitcount = (getStringPartByNr(msg, ',', i + 1)).toInt();

      if (digitcount != glob2)
      {
        glob2 = digitcount;
        EEPROM.put(81, digitcount);
        EEPROM.commit();
        Serial.println("Digit Count into mem");
      }
      //TEMP//updateShiftRegister();
      Serial.println(digitcount);
    }

    //-----------------------------  For Digit POSITION Setting 0 - 72------------------------------------------------------------------

    if ((getStringPartByNr(msg, ',', i) == "DIGITPOSITION"))
    { //---------------  looking for [DIGITPOSITION]  then  [0-30]-----------
      Serial.println(F("got new Digit POSITION"));
      digitpos = (getStringPartByNr(msg, ',', i + 1)).toInt();

      if (digitpos != glob3)
      {
        glob3 = digitpos;
        //        digitpos = ((digitcount * digitpos) - digitcount); // -- to do the math for changing 1-0, 2-3, 3-6, 4-9
        if (digitpos <= 0)
        { //  -- or 1-0, 2-4, 3-8, 4-12
          digitpos = 0;
        }
        EEPROM.put(82, digitpos);
        EEPROM.commit();
        Serial.println("Digit Position into mem");
      }
      //TEMP//updateShiftRegister();
      Serial.println(digitpos);
    }

    //-----------------------------  For Digits A-B-C-D side------------------------------------------------------------------

    //    if ((getStringPartByNr(msg, ',', i) == "DIGITPOSITION")) { //---------------  looking for [DIGITPOSITION]  then  [0-30]-----------
    //      Serial.println(F("got new Digit POSITION"));
    //      digitpos = (getStringPartByNr(msg, ',', i + 1)).toInt();
    //      int glob3;
    //      if (digitpos != glob3) {
    //        glob3 = digitpos;
    //        digitpos = ((digitcount * digitpos) - digitcount);
    //        if (digitpos <= 0) {
    //          digitpos = 0;
    //        }
    //        EEPROM.put(82, digitpos);
    //        EEPROM.commit();
    //        Serial.println("Digit Position into mem");
    //      }
    //      updateShiftRegister();
    //      Serial.println(digitpos);
    //    }

    //-----------------------------  For Digit SET MASTER DIGIT-----------------------------------------------------------------

    if ((getStringPartByNr(msg, ',', i) == "MASTERSLAVE"))
    { //---------------  looking for [MASTERSLAVE]  then 0=off [1-2]-----------{master-slave]
      Serial.println(F("got 0=OFF, 1=Master, 2=Slave"));
      masterslave = (getStringPartByNr(msg, ',', i + 1)).toInt();

      if (masterslave != glob4)
      {
        glob4 = masterslave;
        EEPROM.put(83, masterslave);
        EEPROM.commit();
        Serial.println("MAster Slave into mem");
      }
      Serial.println(masterslave);
    }

    //-----------------------------  For Digit SET CURRENT Position of DIGIT-----------------------------------------------------------------

    if ((getStringPartByNr(msg, ',', i) == "CP"))
    { //---------------  looking for [84][0-45]-----------
      Serial.println(F("got new Current Position"));
      currentpos = (getStringPartByNr(msg, ',', i + 1)).toInt();
      for (int p = 0; p <= digitcount; p++)
      {
        if (currentpos == digitpos + p)
        {
          flash = true;
          //TEMP//updateShiftRegister();
          Serial.println(F("Got Flash"));
          delay(500);
          flash = false;
          //TEMP//updateShiftRegister();
          Serial.println(currentpos);
        }
      }
    }

    //-----------------------------  For Digit to FLASH at CURRENT Position-----------------------------------------------------------------

    if ((getStringPartByNr(msg, ',', i) == "FLASH"))
    { //---------------  looking for [84][0-45]-----------
      Serial.println(F("got new FLASH"));
      remoteflash = true;
      // setBrightness(0);
      //analogWrite(outputEnablePin, 1023);
      // updateShiftRegister();
      Serial.println(F("Got Flash"));
      delay(4000);
      //analogWrite(outputEnablePin, newbrightness);
      //analogWrite(dot_9_10, newbrightness);
      
    }

    //-----------------------------  For Digit or Remote SETTING -----------------------------------------------------------------

    if ((getStringPartByNr(msg, ',', i) == "ACTIVE"))
    { //---------------  looking for [ACTIVE]  then  [0-3]-----------
      Serial.println(F("got ACTIVE Digit, Remote, Repeater"));
      DRRB = (getStringPartByNr(msg, ',', i + 1)).toInt();

      if (DRRB != glob5)
      {
        glob5 = DRRB;
        EEPROM.put(85, DRRB);
        EEPROM.commit();
      }
      Serial.println(DRRB);
      delay(1000);
      ESP.restart();
    }

    //-----------------------------  For Digit FONT Style -----------------------------------------------------------------

    if ((getStringPartByNr(msg, ',', i) == "FONT"))
    { //---------------  looking for [86]  then  [0-3]-----------
      Serial.println(F("got new Digit FONT Style"));
      fontstyle = (getStringPartByNr(msg, ',', i + 1)).toInt();

      if (fontstyle != glob6)
      {
        glob6 = fontstyle;
        EEPROM.begin(512);
        delay(10);
        EEPROM.put(86, fontstyle);
        EEPROM.commit();
        EEPROM.end();
      }
      //TEMP//updateShiftRegister();
      Serial.println(fontstyle);
    }

    //-----------------------------  For MESHSSID Name -----------------------------------------------------------------

    if ((getStringPartByNr(msg, ',', i) == "SETSSID"))
    { //---------------  looking for [SETSSID]  then  [NEW SSID]-----------
      Serial.println(F("got new Mesh SSID"));
      meshssid = getStringPartByNr(msg, ',', i + 1).c_str();
      meshssid = meshssid + '\0';

      if (meshssid != glob7)
      {
        glob7 = meshssid;
        EEPROM.begin(512);
        delay(10);
        for (int i = 0; i < meshssid.length(); ++i)
        {
          if (meshssid[i] == '\0')
            break;
          EEPROM.write(100 + i, meshssid[i]);
          Serial.print("Wrote: ");
          Serial.println(meshssid[i]);
        }
        EEPROM.commit();
        EEPROM.end();
        Serial.println("got SSID update");
        Serial.println(meshssid);
      }
    }

    //-----------------------------  For MESHPASSWORD Name -----------------------------------------------------------------

    if ((getStringPartByNr(msg, ',', i) == "SETPASSWORD"))
    { //---------------  looking for [SETPASSWORD]  then  [NEW PASSWORD]-----------
      Serial.println(F("got new Mesh PASSWORD"));
      meshpassword = (getStringPartByNr(msg, ',', i + 1)).c_str();
      meshpassword = meshpassword + '\0';

      if (meshpassword != glob8)
      {
        glob8 = meshpassword;
        EEPROM.begin(512);
        delay(10);
        for (int i = 0; i < meshpassword.length(); ++i)
        {
          if (meshpassword[i] == '\0')
            break;
          EEPROM.write(120 + i, meshpassword[i]);
          Serial.print("Wrote: ");
          Serial.println(meshpassword[i]);
        }
        EEPROM.commit();
        EEPROM.end();
        Serial.println("got PASS update");
        Serial.println(meshpassword);
      }
    }

    //-----------------------------  For MESHPORT Name -----------------------------------------------------------------

    //    if ((getStringPartByNr(msg, ',', i) == "SETPORT")) { //---------------  looking for [SETPORT]  then  [NEW PORT]-----------
    //      Serial.println(F("got new Mesh PORT"));
    //      meshport = (getStringPartByNr(msg, ',', i + 1)).toInt();
    //      int glob9;
    //      if (meshport != glob9) {
    //        glob9 = meshport;
    //        EEPROM.begin(512);
    //        delay(10);
    //        EEPROM.write(140, meshport);
    //        EEPROM.commit();
    //        EEPROM.end();
    //      }
    //      Serial.println("got Port update");
    //      Serial.println(meshport);
    //    }

    //-----------------------------  For Reseting Sign -----------------------------------------------------------------

    if ((getStringPartByNr(msg, ',', i) == "RESET"))
    { //---------------  looking for [RESET] -----------
      Serial.println(F("got RESET"));
      timerreset.restart();
    }

    //-----------------------------  For Turn Off Digit -----------------------------------------------------------------

    //    if ((getStringPartByNr(msg, ',', i) == "LASTDIGITOFF")) { //---------------  looking for [0,1] ----------- on/off
    //      //   Away to turn off any given digit and account for lack of digit position
    //
    //                Serial.println(F("got new LASTDIGITOFF"));
    //                LDO = (getStringPartByNr(msg, ',', i+1)).toInt();
    //                int glob9;
    //                int portadd = 140;
    //                    if (LDO != glob9){
    //                        glob9 = LDO;
    //                EEPROM.put(portadd, LDO);
    //                EEPROM.commit();
    //                    }
    //                  Serial.println(meshport);
    //                 }
    //    }
    //  EEPROM.end();
  }
  */
}

void newConnectionCallback(uint32_t nodeId)
{
  Serial.printf("--> startHere: New Connection, nodeId = %u\n", nodeId);
  Serial.printf("New Connection %s\n", mesh.subConnectionJson().c_str());
  Serial.println("Connected Node Count: " + String(mesh.getNodeList().size()));

  for(int i = 0; i <= mesh.getNodeList().size(); i++)
  {
    /*if(nodeId_array[i] != nodeId)
    {
      nodeId_array[i] = nodeId;// save the node
      MAXnodesize++;
      String inputMessage5;
      inputMessage5 = MAXnodesize;
      writeFile(SPIFFS, "/MAXnodesize.txt", inputMessage5.c_str());
      i = 500;  //for loop break
    }*/
    for(int j=0;j<(20);j++){
    if((nodeId_array[j] != nodeId) && (nodeId_array[j] <1000))
      {
        nodeId_array[j] = nodeId;// save the node
        j = 500;  //for loop break
        MAXnodesize++;
        String inputMessage5;
        inputMessage5 = MAXnodesize;
        writeFile(SPIFFS, "/MAXnodesize.txt", inputMessage5.c_str());
        Serial.println();
        Serial.println("MAXnodesize in  newConnectionCallback = ");
        Serial.print(MAXnodesize);
      }
      else if((nodeId_array[j] == nodeId))
      {
       j = 500;  //for loop break
      }
      
      
    }
    for(int k=0;k<(20);k++)
    {
      if((live_nodeId_array[k] != nodeId) && (live_nodeId_array[k] <1000))
      {
        live_nodeId_array[k] = nodeId;// save the node
        k = 500;  //for loop break
        LIVEnodesize =  mesh.getNodeList().size();
        Serial.println("NEWConnectionCallback LIVE NODE ADDED");
        Serial.print(live_nodeId_array[k]);
      }
      else if((live_nodeId_array[k] == nodeId))
      {
       k = 500;  //for loop break
       Serial.println("RECIEVED LIVE ALREADY ");
      }
    }

    
  }

  getsensordata();
}
void changedConnectionCallback() 
{
  Serial.printf("Changed connections\n");

  nodes = mesh.getNodeList();
  Serial.printf("Num nodes: %d\n", nodes.size());
  Serial.printf("Connection list:");
  SimpleList<uint32_t>::iterator node = nodes.begin();
  connected_node_size = mesh.getNodeList().size();

  uint32_t mat[nodes.size()][2],mat_nod[10]={0,0,0,0,0,0,0,0,0,0};
  int count_node = 0;
  while (node != nodes.end()) 
    {
      
      Serial.println("new node recieved");
      Serial.printf(" %u", *node);
      mat_nod[count_node] = *node;
      count_node++;
      node++;
    }

  for(int i=0;i<(nodes.size());i++)
  {
    Serial.println("mat_nod[i] = ");
    Serial.println(mat_nod[i]);
    Serial.println();
    for(int j=0;j<(20);j++)
    {
      Serial.println(nodeId_array[j]);
      
      if((mat_nod[i]) == (nodeId_array[j]))
      {
       //i = i+1;  //for loop break
       j = 500;  //for loop break
       Serial.println("RECIEVED MAC ALREADY WRITTEN");
      }
      else if(((nodeId_array[j]) != (mat_nod[i])) && (nodeId_array[j] <1000))
      {
        nodeId_array[j] = mat_nod[i];// save the node
        j = 500;  //for loop break
        MAXnodesize++;
        String inputMessage5;
        inputMessage5 = MAXnodesize;
        
        writeFile(SPIFFS, "/MAXnodesize.txt", inputMessage5.c_str());
        Serial.println();
        Serial.println("MAXnodesize in  changedConnectionCallback = ");
        Serial.print(MAXnodesize);
      }
      
    }
    for(int k=0;k<(20);k++)// live nodes save
    {
      if((live_nodeId_array[k] != mat_nod[i]) && (live_nodeId_array[k] <1000))
      {
        live_nodeId_array[k] = mat_nod[i];// save the node
        k = 500;  //for loop break
        LIVEnodesize =  mesh.getNodeList().size();
        Serial.println("changedConnectionCallback LIVE NODE ADDED");
        Serial.print(live_nodeId_array[k]);
      }
      else if((live_nodeId_array[k] == mat_nod[i]))
      {
       k = 500;  //for loop break
       Serial.println("RECIEVED LIVE ALREADY ");
      }
    }
  }

  if (String(mesh.getNodeList().size()) == "0")
  {
    Serial.println(" RED LED ON");
    digitalWrite(rledpin, HIGH);
    digitalWrite(bledpin, LOW);
  }
  else
  {
    Serial.print(" RED LED OFF");
    digitalWrite(rledpin, LOW);
    digitalWrite(gledpin, LOW);
    digitalWrite(bledpin, HIGH);
  }
 
  if (String(mesh.getNodeList().size()) >= "1")
  {
    // add away to flash 1st digit
    if (DRRB == 1)
    {
      flashone = true;
    }
  }

  if (String(mesh.getNodeList().size()) == "0")
  {
    timerreset2.restart();
    Serial.println("Connection Problem");
    //    ESP.restart();
  }
  else
  {
    Serial.println("Connection GOOD");
    timerreset2.stop();
  }

  getsensordata();

/*
  for(int i=0;i<nodes.size();i++){
    for(int j=0;j<1;j++){
      mat[i][j]= ID;

    }
  }

  for(int i=0;i<nodes.size();i++){
    for(int j=1;j<2;j++){
      mat[i][j] = *node;
      node++;

      //modifiche ulteriori per mandare messaggio ai nodi

      String msg2= "Vaffanculo!";
      mesh.sendSingle(mat[i][j],msg2);
      if(nodeId_array[i] != mat[i][j])
      {
        nodeId_array[i] = mat[i][j];// save the node
        i = 500;  //for loop break
      }
      Serial.printf("STO INVIANDO: %s  al nodo %u\n\n", msg2.c_str(), mat[i][j]);
    }
  }





  
  Serial.println();
  calc_delay = true;
  
  */
  //tft.drawString(buff, 0, 32);
}
/*
void changedConnectionCallback()
{
  Serial.printf("Changed connections %s\n", mesh.subConnectionJson().c_str());
  Serial.println("Connected Node Count: " + String(mesh.getNodeList().size()));
  //Serial.println("Connected Node Count: " + (mesh.getNodeList(bool includeSelf=false)));
  //std::list< uint32_t > = std::list< uint32_t > 	getNodeList (bool includeSelf=false);
  std::list painlessMesh::getNodeList();

  if (String(mesh.getNodeList().size()) == "0")
  {
    Serial.println(" RED LED ON");
    digitalWrite(rledpin, HIGH);
    digitalWrite(bledpin, LOW);
  }
  else
  {
    for(int i = 0; i <= mesh.getNodeList().size(); i++)
  {
    //if(nodeId_array[i] != nodeId)
    {
   //  nodeId_array[i] = nodeId;// save the node
      i = 500;  //for loop break
    }
  }
    Serial.print(" RED LED OFF");
    digitalWrite(rledpin, LOW);
    digitalWrite(gledpin, LOW);
    digitalWrite(bledpin, HIGH);
  }
 
  if (String(mesh.getNodeList().size()) >= "1")
  {
    // add away to flash 1st digit
    if (DRRB == 1)
    {
      flashone = true;
    }
  }

  if (String(mesh.getNodeList().size()) == "0")
  {
    timerreset2.restart();
    Serial.println("Connection Problem");
    //    ESP.restart();
  }
  else
  {
    Serial.println("Connection GOOD");
    timerreset2.stop();
  }

  getsensordata();
}*/

void nodeTimeAdjustedCallback(int32_t offset)
{
  Serial.printf("Adjusted time %u. Offset = %d\n", mesh.getNodeTime(), offset);
  Serial.printf("Adjusted time  connections %s\n", mesh.subConnectionJson().c_str());
  Serial.println("Connected Node Count: " + String(mesh.getNodeList().size()));
  connected_node_size = mesh.getNodeList().size();
}

void delayReceivedCallback(uint32_t from, int32_t delay)
{
  Serial.printf("Delay to node %u is %d us\n", from, delay);
  Serial.printf("Delay to node  connections %s\n", mesh.subConnectionJson().c_str());
  Serial.println("Connected Node Count: " + String(mesh.getNodeList().size()));
  connected_node_size = mesh.getNodeList().size();
}

void droppedConnectionCallback(uint32_t nodeId)
{
  Serial.printf("--> startHere: DROP Connection, nodeId = %u\n", nodeId);
  /*
  for(int i = 0; i < (mesh.getNodeList().size()+1); i++)
  {
    if(nodeId_array[i] == nodeId)
    {
      nodeId_array[i] = 0;// save the node
    }
  }*/
  for(int k=0;k<(20);k++)// live nodes save
    {
      if((live_nodeId_array[k] == nodeId) && (live_nodeId_array[k] > 1000))
      {
        live_nodeId_array[k] = 0;// remove the node
        k = 500;  //for loop break
        LIVEnodesize = mesh.getNodeList().size();
        Serial.println("REMOVE DISCONNECTED MAC");
        Serial.println(nodeId);
      }
      
    }
  connected_node_size = mesh.getNodeList().size();
}

void resetssidpassport()
{

  Serial.println("RESETING SIDD and PASSWORD and PORT");

  meshssid = "GAP";
  meshssid = meshssid + '\0';
  if (meshssid != glob7)
  {
    glob7 = meshssid;
    EEPROM.begin(512);
    delay(10);
    for (int i = 0; i < meshssid.length(); ++i)
    {
      if (meshssid[i] == '\0')
        break;
      EEPROM.write(100 + i, meshssid[i]);
      Serial.print("Wrote: ");
      Serial.println(meshssid[i]);
    }
    EEPROM.commit();
    EEPROM.end();
    Serial.println("got SSID update");
    Serial.println(meshssid);
  }

  meshpassword = "12345678";
  meshpassword = meshpassword + '\0';
  if (meshpassword != glob8)
  {
    glob8 = meshpassword;
    EEPROM.begin(512);
    delay(10);
    for (int i = 0; i < meshpassword.length(); ++i)
    {
      if (meshpassword[i] == '\0')
        break;
      EEPROM.write(120 + i, meshpassword[i]);
      Serial.print("Wrote: ");
      Serial.println(meshpassword[i]);
    }
    EEPROM.commit();
    EEPROM.end();
    Serial.println("got PASS update");
    Serial.println(meshpassword);
  }

  timerreset.restart();
}



void hmi_price_value_update()
{
  hmi_price_digit[1]  = price_digit1;
  hmi_price_digit[3]  = price_digit2;
  hmi_price_digit[5]  = price_digit3;
  hmi_price_digit[7]  = price_digit4;
  hmi_price_digit[9]  = price_digit5;
  hmi_price_digit[11]  = price_digit6;
  hmi_price_digit[13]  = price_digit7;
  hmi_price_digit[15]  = price_digit8;
  hmi_price_digit[17]  = price_digit9;
  hmi_price_digit[19]  = price_digit10;
  hmi_price_digit[21]  = price_digit11;
  hmi_price_digit[23]  = price_digit12;
  hmi_price_digit[25]  = price_digit13;
  hmi_price_digit[27]  = price_digit14;
  hmi_price_digit[29]  = price_digit15;
  hmi_price_digit[31]  = price_digit16;
  hmi_price_digit[33]  = price_digit17;
  hmi_price_digit[35]  = price_digit18;
  hmi_price_digit[37]  = price_digit19;
  hmi_price_digit[39]  = price_digit20;
  hmi_price_digit[41]  = price_digit21;
  hmi_price_digit[43]  = price_digit22;
  hmi_price_digit[45]  = price_digit23;
  hmi_price_digit[47]  = price_digit24;
  hmi_price_digit[49]  = price_digit25;
  hmi_price_digit[51]  = price_digit26;
  hmi_price_digit[53]  = price_digit27;
  hmi_price_digit[55]  = price_digit28;
  hmi_price_digit[57]  = price_digit29;
  hmi_price_digit[59]  = price_digit30;
  hmi_price_digit[61]  = price_digit31;
  hmi_price_digit[63]  = price_digit32;
  hmi_price_digit[65]  = price_digit33;
  hmi_price_digit[67]  = price_digit34;
  hmi_price_digit[69]  = price_digit35;
  hmi_price_digit[71]  = price_digit36;
  hmi_price_digit[73]  = price_digit37;
  hmi_price_digit[75]  = price_digit38;
  hmi_price_digit[77]  = price_digit39;
  hmi_price_digit[79]  = price_digit40;
  hmi_price_digit[81]  = price_digit41;
  hmi_price_digit[83]  = price_digit42;
  hmi_price_digit[85]  = price_digit43;
  hmi_price_digit[87]  = price_digit44;
  hmi_price_digit[89]  = price_digit45;
  hmi_price_digit[91]  = price_digit46;
  hmi_price_digit[93]  = price_digit47;
  hmi_price_digit[95]  = price_digit48;

  if(num_of_groups == 4)
  {
    for (int x = 1; x < (num_of_groups *3 *2); x+=2) { //cash
    hmi_price_digit_g[x] = hmi_price_digit[x];
  }
  for (int y = ((num_of_groups *3 *2)+1); y < (num_of_groups *3 *4); y+=2) { //cash
    hmi_price_digit_g[y+24] = hmi_price_digit[y];
  }
  }
  else if(num_of_groups == 5)
  {
    for (int x = 1; x < (num_of_groups *3 *2); x+=2) { //cash
    hmi_price_digit_g[x] = hmi_price_digit[x];
    }
    for (int y = ((num_of_groups *3 *2)+1); y < (num_of_groups *3 *4); y+=2) { //cash
      hmi_price_digit_g[y+18] = hmi_price_digit[y];
    }
  }
  else if(num_of_groups == 6)
  {
    for (int x = 1; x < (num_of_groups *3 *2); x+=2) { //cash
    hmi_price_digit_g[x] = hmi_price_digit[x];
    }
    for (int y = ((num_of_groups *3 *2)+1); y < (num_of_groups *3 *4); y+=2) { //cash
      hmi_price_digit_g[y+12] = hmi_price_digit[y];
    }
  }
  else if(num_of_groups == 7)
  {
    for (int x = 1; x < (num_of_groups *3 *2); x+=2) { //cash
    hmi_price_digit_g[x] = hmi_price_digit[x];
    }
    for (int y = ((num_of_groups *3 *2)+1); y < (num_of_groups *3 *4); y+=2) { //cash
      hmi_price_digit_g[y+6] = hmi_price_digit[y];
    }
  }
  else
  {
    for (int y = 1; y < 96; y+=2) { //cash
    hmi_price_digit_g[y] = hmi_price_digit[y];
    }
  }
}


//============================================================= RF price and brightness INTERMEDIATOR ============================//
void sendCommand(int position, int command, int value)
{
  digitalWrite(BLUE_LED_POS,HIGH); //SENDING VALUES TO BOARD
  int digit_value = value;
  char buffer[8];
  switch (command) {
    case 5:  //send value directly
      //delay(80);
      digitalWrite(8, 0);
      delay(10);
      digitalWrite(8, 1);
      itoa((position << 8) | ((digit_value << 3) | 5), buffer, 10);
      //delay(40);
      //Serial.println("sent 5");
      //delay(40);
      break;
      case 6:  //sendBRIGHTNESS
      delay(80);
      digitalWrite(8, 0);
      delay(20);
      digitalWrite(8, 1);
      //itoa((position << 8) | ((bright_range << 3) | 1), buffer, 10);
      itoa((position << 8) | bright_range, buffer, 10);
      delay(40);
    break;
    case 7:  //sendBRIGHTNESS
      delay(80);
      digitalWrite(8, 0);
      delay(20);
      digitalWrite(8, 1);
      itoa((position << 8) | ((digit_value << 3) | 6), buffer, 10);
      delay(40);
    break;
    /*
    case 6:  //sendBRIGHTNESS
      delay(80);
      digitalWrite(8, 0);
      delay(20);
      digitalWrite(8, 1);
      //itoa((position << 8) | ((bright_range << 3) | 1), buffer, 10);
      itoa((position << 8) | ((digit_value << 3) | 6), buffer, 10);
      //itoa((position << 8) | bright_range, buffer, 10);
      delay(40);
    break;
    
    case 6:
    delay(80);
      digitalWrite(8, 0);
      delay(20);
      digitalWrite(8, 1);
      itoa((position << 8) | bright_range, buffer, 10);
      delay(60);
      Serial.println("Bright change");
      //delay(60);
      break;*/
  }
  Serial2.println(buffer);
  Serial.println(buffer);
  //delay(200);
  //digitalWrite(8, 0); // enter AT command mode
  delay(80);
  //Serial2.print(F("AT+SLEEP"));
  String input = Serial2.readString();
  Serial.println(input);
  delay(80);
  //digitalWrite(8, 1); // enter transparent mode
  //delay(40);
  delayRunning = true; //start flash timer
  digitalWrite(BLUE_LED_POS,LOW); //SENDING VALUES TO BOARD
}

//============================================================= CDC RF INTERMEDIATOR ============================//
void sendCDC_INTERMEDIATOR(int command ,int value1)
{
  digitalWrite(BLUE_LED_POS,HIGH); //SENDING VALUES TO BOARD
  char buffer[8];
  switch (command) {
    case 1:
    // FLASH ON OFF //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((123<<8) | value1, buffer, 10);
    delay(400);
    Serial.println("GOT FLASH ON/OFF");
    break;
    case 2:
    // FLASH TIMING //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((124<<8) | flash_time, buffer, 10);
    delay(400);
    Serial.println("got the seconds");
    break;
    case 3:
    // FLASH STYLE LEVEL DISPLAY //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((121<<8) | flash_style, buffer, 10);
    delay(400);
    Serial.println("got the flash style");
    break;
    case 4:
    // FLASH CASH ON/OFF //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((125<<8) | con_cash, buffer, 10);
    delay(400);
    Serial.println("got the CASH led on or off");
    break;
    case 5:
    // FLASH DEBIT ON/OFF //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((122<<8) | con_debit, buffer, 10);
    delay(400);
    Serial.println("got the DEBIT led on or off");
    break;
    case 6:
    // FLASH CREDIT ON/OFF //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((126<<8) | con_credit, buffer, 10);
    delay(400);
    Serial.println("got the CREDIT led on or off");
    break;
    case 7:
    //MASTER RF CHANNEL NUM SET //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((118 << 8) | ((master_RF_channel_num << 3) | 0), buffer, 10);
    delay(400);
    Serial.println("MASTER RF CHANNEL SELECTION");
    break;
    case 8:
    // MASTER RF CHANNEL NUM SAVE //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((118 << 8) | ((master_RF_channel_num << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("MASTER RF CHANNEL SAVE");
    break;
    case 9:
    // SECONDARY RF CHANNEL NUM SET //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((119 << 8) | ((secondary_RF_channel_num << 3) | 0), buffer, 10);
    delay(400);
    Serial.println("SECONDARY RF CHANNEL SELECTION");
    break;
    case 10:
    // SECONDARY RF CHANNEL SAVE//
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((119 << 8) | ((secondary_RF_channel_num << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("SECONDARY RF CHANNEL SAVE");
    break;
    case 11:
    // ALL BOARDS RF CHANNEL NUM DISPLAY //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((117 << 8) | ((value1 << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("ALL BOARDS RF CHANNEL DISPLAY");
    break;
    case 12:
    // ALL BOARDS RF CHANNEL NUM DISPLAY //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((116 << 8) | ((master_RF_channel_num << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("ALL BOARDS RF CHANNEL DISPLAY");
    break;
    case 13:
    // ALL BOARDS RF CHANNEL NUM DISPLAY //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((115 << 8) | ((value1 << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("REMOTE AND POS  RF CHANNEL DISPLAYREQUEST ");
    break;
    case 14:
    // grade set num allocate update//
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((78 << 8) | ((value1 << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("BOARDS GRADE ALLOCATE");
    break;
    case 15:
    // TOTAL NUM OF GRADES LOGIC IN BOARD//
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((79 << 8) | ((Max_grade_env << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("BOARDS TOTAL GRADE SEND");
    break;
    case 16:
    // BOARD MASTER OR SECONDARY SELECTION//
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((77 << 8) | ((Master_sec_board << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("BOARDS MASTER & SECONDARY SELECTION ");
    break;
    case 17:
    // BOARD MASTER OR SECONDARY SELECTION//
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((76 << 8) | ((value1 << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("DISPLAY GRADE ORDER");
    break;
    case 18:
    // BOARD MASTER OR SECONDARY SELECTION//
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((75 << 8) | ((value1 << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("DISPLAY GRADE ORDER");
    break;
    case 19:
    // BOARD MASTER OR SECONDARY SELECTION//
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((80 << 8) | ((value1 << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("SLEEP MODE SEND");
    break;
    case 20:
    // GRADE CONTROL SELECTION //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((61 << 8) | ((value1 << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("GRADE CONTROL SEND");
    break;
    case 21:
    // CHANNEL CONTROL SELECTION //
    delay(80);
    digitalWrite(8, 0);
    delay(20);
    digitalWrite(8, 1);
    itoa((62 << 8) | ((value1 << 3) | 1), buffer, 10);
    delay(400);
    Serial.println("CHANNEL CONTROL SEND");
    break;
  }
  Serial2.println(buffer);
  Serial.println(buffer);
  delay(200);
  digitalWrite(8, 0); // enter AT command mode
  delay(80);
  Serial2.print(F("AT+SLEEP"));
  String input = Serial2.readString();
  Serial.println(input);
  delay(80);
  digitalWrite(8, 1); // enter transparent mode
  delay(40);
  delayRunning = true; //start flash timer
  digitalWrite(BLUE_LED_POS,LOW); //SENDING VALUES TO BOARD
}
//============================================ RF FONT INTERMEDIATOR ===============================//
void sendFont_RF(int font)
{
  digitalWrite(BLUE_LED_POS,HIGH); //SENDING VALUES TO BOARD
  char buffer[8];
  switch (font) {
    case 1:  //send value directly
      delay(80);
      digitalWrite(8, 0);
      delay(20);
      digitalWrite(8, 1);
      itoa(7001, buffer, 10);
      delay(40);
      //Serial.println("sent 5");
      //delay(40);
      break;
    case 2:
    delay(80);
      digitalWrite(8, 0);
      delay(20);
      digitalWrite(8, 1);
      itoa(7002, buffer, 10);
      delay(60);
      //Serial.println("Bright change");
      //delay(60);
      break;
    case 3:
      delay(80);
      digitalWrite(8, 0);
      delay(20);
      digitalWrite(8, 1);
      itoa(7003, buffer, 10);
      delay(60);
      //Serial.println("Bright change");
      //delay(60);
      break;
  }
  Serial2.println(buffer);
  Serial.println(buffer);
  //delay(200);
  digitalWrite(8, 0); // enter AT command mode
  delay(80);
  Serial2.print(F("AT+SLEEP"));
  String input = Serial2.readString();
  Serial.println(input);
  delay(80);
  digitalWrite(8, 1); // enter transparent mode
  //delay(40);
  delayRunning = true; //start flash timer
  digitalWrite(BLUE_LED_POS,LOW); //SENDING VALUES TO BOARD
}




void resend_data()  //intermediator grades value resend
{
  price_grade_1_update= true,price_grade_2_update = true,price_grade_3_update= true,price_grade_4_update= true,price_grade_5_update= true,price_grade_6_update= true,price_grade_7_update= true,price_grade_8_update = true;
  price_grade_9_update= true,price_grade_10_update= true,price_grade_11_update= true,price_grade_12_update= true,price_grade_13_update= true,price_grade_14_update = true,price_grade_15_update= true,price_grade_16_update = true;
  intermediator_price_update = true;
  
}


void setup_led_blink()
{ 
  if(led_blink == true)
  {
    //blink led
    stop_blink = true;
    if(((millis() - led_blink_time_on) > 1500 ) && (led_blink_status == 0))
    {
      //ledcWrite(ledChannel, (0)); //on led
      //TEMP//setBrightness(led_full_off);
      digitalWrite(BLUE_LED_POS, HIGH);
      digitalWrite(WHITE_LED_POS, HIGH);
      digitalWrite(RED_LED_POS, HIGH);
      led_blink_time_on = millis();
      led_blink_status = 1;
    }
    else if(((millis() - led_blink_time_on) >= 800 ) && (led_blink_status == 1))
    {
      //ledcWrite(ledChannel, (256)); //off led
      //TEMP//setBrightness(led_full_on);
      digitalWrite(BLUE_LED_POS, LOW);
      digitalWrite(WHITE_LED_POS, LOW);
      digitalWrite(RED_LED_POS, LOW);
      led_blink_time_on = millis();
      led_blink_status = 0;
    }
  }
  else if(stop_blink == true)
  {
    // stop blinking
    //TEMP//setBrightness(led_full_on);
    digitalWrite(BLUE_LED_POS, LOW);
    digitalWrite(WHITE_LED_POS, LOW);
    digitalWrite(RED_LED_POS, HIGH);
    stop_blink = false;
  }
}
void position_start()
{

}

void data_recieve_app()
{ 
  if(brightness_update==true)     //Brightness Update Loop
  {
    Brightness=readFile(SPIFFS, "/Brightvalue.txt").toInt();
    //TEMP//setBrightness(Brightness);
    bright_range= map(Brightness, 0, 255, 0, 4);

    if(wifi_mode == true){  // -------------- wifi mode enable
    //=========== mesh brightness transmit ==================================//
    Serial.println(" SENDING BRIGHTNESS ");
    Serial.println(" brightness is = " + Brightness);
    int bright_rang_wifi= map(Brightness, 0, 255, 0, 4);
    String br = "BRIGHTNESS," + String(bright_rang_wifi) + ",";
    mesh.sendBroadcast(br);
    taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
    }
    if(rf_mode == true){  // --------------------- rf mode enable
    //=============== RF TRANSMIT =================================================//
    Serial.print("Brightness range for intermediator =");
    Serial.println(bright_range);
    sendCommand(127, 6,0);
    }
    brightness_update = false;
  }
  if(price_change==true)      //Price Update Loop
  {
    
      price_grade1=readFile(SPIFFS, "/price_grade1.txt").toInt();
      dec_price_grade1 = price_grade1; // * 100.0;
      price_digit3 = dec_price_grade1%10;
      dec_price_grade1/=10;
      price_digit2 = dec_price_grade1%10;
      dec_price_grade1/=10;
      price_digit1 = dec_price_grade1%10;

      price_grade2=readFile(SPIFFS, "/price_grade2.txt").toInt();
      dec_price_grade2 = price_grade2; // * 100.0;
      price_digit6 = dec_price_grade2 % 10;
      dec_price_grade2 /= 10;
      price_digit5 = dec_price_grade2 % 10;
      dec_price_grade2 /= 10;
      price_digit4 = dec_price_grade2 % 10;

      price_grade3=readFile(SPIFFS, "/price_grade3.txt").toInt();
      dec_price_grade3 = price_grade3; // * 100.0;
      price_digit9 = dec_price_grade3 % 10;
      dec_price_grade3 /= 10;
      price_digit8 = dec_price_grade3 % 10;
      dec_price_grade3 /= 10;
      price_digit7 = dec_price_grade3 % 10;

      Serial.println(price_digit1);
      Serial.println(price_digit2);
      Serial.println(price_digit3);
      Serial.println(price_digit4);
      Serial.println(price_digit5);
      Serial.println(price_digit6);
      Serial.println(price_digit7);
      Serial.println(price_digit8);
      Serial.println(price_digit9);
    
    //if(num_of_groups >= 4)
    {
      price_grade4=readFile(SPIFFS, "/price_grade4.txt").toInt();
      dec_price_grade4 = price_grade4; // * 100.0;
      price_digit12 = dec_price_grade4%10;
      dec_price_grade4/=10;
      price_digit11 = dec_price_grade4%10;
      dec_price_grade4/=10;
      price_digit10 = dec_price_grade4%10;

      Serial.println(price_digit10);
      Serial.println(price_digit11);
      Serial.println(price_digit12);

    }
    //if(num_of_groups >= 5)
    {
      price_grade5=readFile(SPIFFS, "/price_grade5.txt").toInt();
      dec_price_grade5 = price_grade5; // * 100.0;
      price_digit15 = dec_price_grade5%10;
      dec_price_grade5/=10;
      price_digit14 = dec_price_grade5%10;
      dec_price_grade5/=10;
      price_digit13 = dec_price_grade5%10;

      Serial.println(price_digit13);
      Serial.println(price_digit14);
      Serial.println(price_digit15);

    }
    //if(num_of_groups >= 6)
    {
      price_grade6=readFile(SPIFFS, "/price_grade6.txt").toInt();
      dec_price_grade6 = price_grade6; // * 100.0;
      price_digit18 = dec_price_grade6%10;
      dec_price_grade6/=10;
      price_digit17 = dec_price_grade6%10;
      dec_price_grade6/=10;
      price_digit16 = dec_price_grade6%10;

      Serial.println(price_digit16);
      Serial.println(price_digit17);
      Serial.println(price_digit18);
    }

    //if((group_type == 1) || (flashing == 1))
    {
      price_grade7=readFile(SPIFFS, "/price_grade7.txt").toInt();
      dec_price_grade7 = price_grade7; // * 100.0;
      price_digit21 = dec_price_grade7%10;
      dec_price_grade7/=10;
      price_digit20 = dec_price_grade7%10;
      dec_price_grade7/=10;
      price_digit19 = dec_price_grade7%10;
      Serial.println(price_digit19);
      Serial.println(price_digit20);
      Serial.println(price_digit21);

      price_grade8=readFile(SPIFFS, "/price_grade8.txt").toInt();
      dec_price_grade8 = price_grade8; // * 100.0;
      price_digit24 = dec_price_grade8 % 10;
      dec_price_grade8 /= 10;
      price_digit23 = dec_price_grade8 % 10;
      dec_price_grade8 /= 10;
      price_digit22 = dec_price_grade8 % 10;

      price_grade9=readFile(SPIFFS, "/price_grade9.txt").toInt();
      dec_price_grade9 = price_grade9; // * 100.0;
      price_digit27 = dec_price_grade9 % 10;
      dec_price_grade9 /= 10;
      price_digit26 = dec_price_grade9 % 10;
      dec_price_grade9 /= 10;
      price_digit25 = dec_price_grade9 % 10;
      /*
      Serial.println(price_digit22);
      Serial.println(price_digit23);
      Serial.println(price_digit24);
      Serial.println(price_digit25);
      Serial.println(price_digit26);
      Serial.println(price_digit27);*/
    
     // if(num_of_groups >= 4)
      {
        price_grade10=readFile(SPIFFS, "/price_grade10.txt").toInt();
        dec_price_grade10 = price_grade10; // * 100.0;
        price_digit30 = dec_price_grade10%10;
        dec_price_grade10/=10;
        price_digit29 = dec_price_grade10%10;
        dec_price_grade10/=10;
        price_digit28 = dec_price_grade10%10;
        /*
        Serial.println(price_digit28);
        Serial.println(price_digit29);
        Serial.println(price_digit30);
        */

      }
     // if(num_of_groups >= 5)
      {
        price_grade11=readFile(SPIFFS, "/price_grade11.txt").toInt();
        dec_price_grade11 = price_grade11; // * 100.0;
        price_digit33 = dec_price_grade11%10;
        dec_price_grade11/=10;
        price_digit32 = dec_price_grade11%10;
        dec_price_grade11/=10;
        price_digit31 = dec_price_grade11%10;

        Serial.println(price_digit31);
        Serial.println(price_digit32);
        Serial.println(price_digit33);

      }
      //if(num_of_groups >= 6)
      {
        price_grade12=readFile(SPIFFS, "/price_grade12.txt").toInt();
        dec_price_grade12 = price_grade12; // * 100.0;
        price_digit36 = dec_price_grade12%10;
        dec_price_grade12/=10;
        price_digit35 = dec_price_grade12%10;
        dec_price_grade12/=10;
        price_digit34 = dec_price_grade12%10;

        Serial.println(price_digit34);
        Serial.println(price_digit35);
        Serial.println(price_digit36);
      } 

      {
        price_grade13=readFile(SPIFFS, "/price_grade13.txt").toInt();
        dec_price_grade13 = price_grade13; // * 100.0;
        price_digit39 = dec_price_grade13%10;
        dec_price_grade13/=10;
        price_digit38 = dec_price_grade13%10;
        dec_price_grade13/=10;
        price_digit37 = dec_price_grade13%10;

        Serial.println(price_digit37);
        Serial.println(price_digit38);
        Serial.println(price_digit39);
      }

      {
        price_grade14=readFile(SPIFFS, "/price_grade14.txt").toInt();
        dec_price_grade14 = price_grade14; // * 100.0;
        price_digit42 = dec_price_grade14%10;
        dec_price_grade14/=10;
        price_digit41 = dec_price_grade14%10;
        dec_price_grade14/=10;
        price_digit40 = dec_price_grade14%10;

        Serial.println(price_digit40);
        Serial.println(price_digit41);
        Serial.println(price_digit42);
      }
      {
        price_grade15=readFile(SPIFFS, "/price_grade15.txt").toInt();
        dec_price_grade15 = price_grade15; // * 100.0;
        price_digit45 = dec_price_grade15%10;
        dec_price_grade15/=10;
        price_digit44 = dec_price_grade15%10;
        dec_price_grade15/=10;
        price_digit43 = dec_price_grade15%10;

        Serial.println(price_digit43);
        Serial.println(price_digit44);
        Serial.println(price_digit45);
      }
      {
        price_grade16=readFile(SPIFFS, "/price_grade16.txt").toInt();
        dec_price_grade16 = price_grade16; // * 100.0;
        price_digit48 = dec_price_grade16%10;
        dec_price_grade16/=10;
        price_digit47 = dec_price_grade16%10;
        dec_price_grade16/=10;
        price_digit46 = dec_price_grade16%10;

        Serial.println(price_digit46);
        Serial.println(price_digit47);
        Serial.println(price_digit48);
      }
    }
   
    //position_start();
    //updateShiftRegister();
    price_change=false;
    if(rf_price_transmit == false)
    {
      intermediator_price_update=true; 
    }
    else
    {
      rf_price_transmit = false;
    }   
  }
}
void data_transmit_rf()
{ 
  if(intermediator_price_update == true)    // temp off because no transmit
  {
    
    if(price_grade_1_update == true)
    {
      price_grade_1_update = false;
      sendCommand(0, 5, price_digit1);
      sendCommand(1, 5, price_digit2);
      sendCommand(2, 5, price_digit3);
    }
    if(price_grade_2_update == true)
    {
      price_grade_2_update = false;
      sendCommand(3, 5, price_digit4);
      sendCommand(4, 5, price_digit5);
      sendCommand(5, 5, price_digit6);
    }
    if(price_grade_3_update == true)
    {
      price_grade_3_update = false;
      sendCommand(6, 5, price_digit7);
      sendCommand(7, 5, price_digit8);
      sendCommand(8, 5, price_digit9);
    }
    if(price_grade_4_update == true)
    {
      price_grade_4_update = false;
      //if(num_of_groups >= 4)
      {
        sendCommand(9, 5, price_digit10);
        sendCommand(10, 5, price_digit11);
        sendCommand(11, 5, price_digit12);
      }
    }
    if(price_grade_5_update == true)
    {
      price_grade_5_update = false;
      //if(num_of_groups >= 5)
      {
        sendCommand(12, 5, price_digit13);
        sendCommand(13, 5, price_digit14);
        sendCommand(14, 5, price_digit15);
      }
    }
    if(price_grade_6_update == true)
    {
      price_grade_6_update = false;
      //if(num_of_groups >= 6)
      {
        sendCommand(15, 5, price_digit16);
        sendCommand(16, 5, price_digit17);
        sendCommand(17, 5, price_digit18);
      }
    }
    if(price_grade_7_update == true)
      {
        price_grade_7_update = false;
        sendCommand(18, 5, price_digit19);
        sendCommand(19, 5, price_digit20);
        sendCommand(20, 5, price_digit21);
      }
      if(price_grade_8_update == true)
      {
        price_grade_8_update = false;
        sendCommand(21, 5, price_digit22);
        sendCommand(22, 5, price_digit23);
        sendCommand(23, 5, price_digit24);
      }  
      // for credit
    if((group_type == 1) || (flashing == 1))
    {
      
      /*
      sendCommand(12, 5, price_digit13);
      sendCommand(13, 5, price_digit14);
      sendCommand(14, 5, price_digit15);
      sendCommand(15, 5, price_digit16);
      sendCommand(16, 5, price_digit17);
      sendCommand(17, 5, price_digit18);
      */
      
      if(price_grade_9_update == true)
      {
        price_grade_9_update = false;
        sendCommand(24, 5, price_digit25);
        sendCommand(25, 5, price_digit26);
        sendCommand(26, 5, price_digit27);
      }
      if(price_grade_10_update == true)
      {
        price_grade_10_update = false;
        //if(num_of_groups >= 4)
        {
          sendCommand(27, 5, price_digit28);
          sendCommand(28, 5, price_digit29);
          sendCommand(29, 5, price_digit30);
        }
      }
      if(price_grade_11_update == true)
      {
        price_grade_11_update = false;
        //if(num_of_groups >= 5)
        {
          sendCommand(30, 5, price_digit31);
          sendCommand(31, 5, price_digit32);
          sendCommand(32, 5, price_digit33);
        }
      }
      if(price_grade_12_update == true)
      {
        price_grade_12_update = false;
        //if(num_of_groups >= 6)
        {
          sendCommand(33, 5, price_digit34);
          sendCommand(34, 5, price_digit35);
          sendCommand(35, 5, price_digit36);
        }
      }
      if(price_grade_13_update == true)
      {
        price_grade_13_update = false;
        //if(num_of_groups >= 6)
        {
          sendCommand(36, 5, price_digit37);
          sendCommand(37, 5, price_digit38);
          sendCommand(38, 5, price_digit39);
        }
      }
      if(price_grade_14_update == true)
      {
        price_grade_14_update = false;
        //if(num_of_groups >= 6)
        {
          sendCommand(39, 5, price_digit40);
          sendCommand(40, 5, price_digit41);
          sendCommand(41, 5, price_digit42);
        }
      }
      if(price_grade_15_update == true)
      {
        price_grade_15_update = false;
        //if(num_of_groups >= 6)
        {
          sendCommand(42, 5, price_digit43);
          sendCommand(43, 5, price_digit44);
          sendCommand(44, 5, price_digit45);
        }
      }
      if(price_grade_16_update == true)
      {
        price_grade_16_update = false;
        //if(num_of_groups >= 6)
        {
          sendCommand(45, 5, price_digit46);
          sendCommand(46, 5, price_digit47);
          sendCommand(47, 5, price_digit48);
        }
      }
    }
    intermediator_price_update = false;
    // =========================== MESH PRICE TRANSMIT =============================//
    String sync;
    //for (int i = 0; i < 36; i++)
    //{
    //  sync += digits[i] + "," + String(digitval[i]) + ",";
    //  yield();
    //}
    //Serial.println(sync);
    //mesh.sendBroadcast(sync);
    //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
    //Serial.println("sync MSG SENDING FROM DATA UPDATE");
    //hmi.HMT_BuzzerCtrl(0x01,0x02,0X02,0X0A,0X0A); // new buzzer tone
    //delay(500);
    //hmi.HMT_BuzzerCtrl(0x01,0x01,0X01,0x15,0X15); // new buzzer tone
    
    //Serial.println("Buzzer beep");

  }

  
  /*
  if(CDC_update == 1)
  {
    CDC_update = 0;
    
    //==================== CDC MODES =================================//
    if(flashing == 0)
    {
      if(con_cash == 1)
      {
        setcashbri(Brightness);
      }
      else
      {
        setcashbri(led_full_off);
      }
      if(con_debit == 1)
      {
        setdebitbri(Brightness);
      }
      else
      {
        setdebitbri(led_full_off); 
      }
      if(con_credit == 1)
      {
        setcreditbri(Brightness);
      }
      else
      {
        setcreditbri(led_full_off);
      }
      
    }
  }*/
 // ========================== CDC RF UPDATE ==========================//
  if (cdc_RF_update == true)
  {
    if(flashing == 1)
    {
      sendCDC_INTERMEDIATOR(1,0); //cdc flash ON
      sendCDC_INTERMEDIATOR(2,flash_time); //CDC FLASH TIME SET
      sendCDC_INTERMEDIATOR(3,flash_style); // cdc flash style SET
    }
    else
    {
      sendCDC_INTERMEDIATOR(1,1); //cdc flash OFF
      sendCDC_INTERMEDIATOR(4,0); //cdc cash led on or off""
      sendCDC_INTERMEDIATOR(5,0); //cdc debit led on or off""
      sendCDC_INTERMEDIATOR(6,0); //cdc credit led on or off""
    }
    cdc_RF_update = false;
    Serial.println("CDC RF UPDATE DONE");
  }
  if (Advanced_RF_update == true)
  {
    Advanced_RF_update = false;
    sendCDC_INTERMEDIATOR(1,0); //cdc flash ON
    flash_style = 6;
    sendCDC_INTERMEDIATOR(3,flash_style); // cdc flash style SET
    sendCDC_INTERMEDIATOR(4,0); //cdc cash led on or off""
    sendCDC_INTERMEDIATOR(5,0); //cdc debit led on or off""
    sendCDC_INTERMEDIATOR(6,0); //cdc credit led on or off""
  }
  
}
//============================== POS INTERFACE SERIAL =============================//

void showNewData() {

  for (int x = 0; x < 13; x++) {
    Serial.print(receivedChars2[x]);
  }
  Serial.println("");
  waitingforlrc = false; 


  if (receivedChars2[0] == '1' && receivedChars2[1] == '0' && receivedChars2[2] == '0') {
    Serial.println("Got 100");
    if (inite) {
      GILL_VER_SERIAL.write(2);
      GILL_VER_SERIAL.write(49);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(3);
      GILL_VER_SERIAL.write(2);
      Serial.println("sending start");
    } else {
      GILL_VER_SERIAL.write(2);
      GILL_VER_SERIAL.write(49);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(49);
      GILL_VER_SERIAL.write(3);
      GILL_VER_SERIAL.write(3);
      Serial.println("sending IDLE");
    }

    for (int x = 0; x < numChars; x++) {
      receivedChars2[x] = 0;
    }

  }

  if (receivedChars2[0] == '1' && receivedChars2[1] == '0' && receivedChars2[2] == '1') {

    if (inite) {
      GILL_VER_SERIAL.write(2);
      GILL_VER_SERIAL.write(49);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(48);
      GILL_VER_SERIAL.write(3);
      GILL_VER_SERIAL.write(2);
      Serial.println("sending start");
    } else {
      GILL_VER_SERIAL.write(6);
      Serial.println("Got 101");
      Serial.println("sending ACK");
    }


    if (receivedChars2[3] == '0' && receivedChars2[4] == '0') {
      Serial.println("Got PRO-1");
      GILL_VER_digitval[0] = receivedChars2[7] - '0';
      GILL_VER_digitval[1] = receivedChars2[8] - '0';
      GILL_VER_digitval[2] = receivedChars2[9] - '0';
      Serial.print(GILL_VER_digitval[0]);
      Serial.print(".");
      Serial.print(GILL_VER_digitval[1]);
      Serial.println(GILL_VER_digitval[2]);
      timerupdate.restart();
    }
    if (receivedChars2[3] == '0' && receivedChars2[4] == '1') {
      Serial.println("Got PRO-2");
      if (receivedChars2[7] && receivedChars2[8] && receivedChars2[9] >= 0) {
        GILL_VER_digitval[3] = receivedChars2[7] - '0';
        GILL_VER_digitval[4] = receivedChars2[8] - '0';
        GILL_VER_digitval[5] = receivedChars2[9] - '0';
        Serial.print(GILL_VER_digitval[3]);
        Serial.print(".");
        Serial.print(GILL_VER_digitval[4]);
        Serial.println(GILL_VER_digitval[5]);
        timerupdate.restart();
      }
    }
    if (receivedChars2[3] == '0' && receivedChars2[4] == '2') {
      Serial.println("Got PRO-3");
      if (receivedChars2[7] && receivedChars2[8] && receivedChars2[9] >= 0) {
        GILL_VER_digitval[6] = receivedChars2[7] - '0';
        GILL_VER_digitval[7] = receivedChars2[8] - '0';
        GILL_VER_digitval[8] = receivedChars2[9] - '0';
        Serial.print(GILL_VER_digitval[6]);
        Serial.print(".");
        Serial.print(GILL_VER_digitval[7]);
        Serial.println(GILL_VER_digitval[8]);
        timerupdate.restart();
      }
    }
    if (receivedChars2[3] == '0' && receivedChars2[4] == '3') {
      Serial.println("Got PRO-4");
      if (receivedChars2[7] && receivedChars2[8] && receivedChars2[9] >= 0) {
        GILL_VER_digitval[9] = receivedChars2[7] - '0';
        GILL_VER_digitval[10] = receivedChars2[8] - '0';
        GILL_VER_digitval[11] = receivedChars2[9] - '0';
        Serial.print(GILL_VER_digitval[9]);
        Serial.print(".");
        Serial.print(GILL_VER_digitval[10]);
        Serial.println(GILL_VER_digitval[11]);
        timerupdate.restart();
      }
    }
    if (receivedChars2[3] == '0' && receivedChars2[4] == '4') {
      Serial.println("Got PRO-5");
      if (receivedChars2[7] && receivedChars2[8] && receivedChars2[9] >= 0) {
        GILL_VER_digitval[12] = receivedChars2[7] - '0';
        GILL_VER_digitval[13] = receivedChars2[8] - '0';
        GILL_VER_digitval[14] = receivedChars2[9] - '0';
        Serial.print(GILL_VER_digitval[12]);
        Serial.print(".");
        Serial.print(GILL_VER_digitval[13]);
        Serial.println(GILL_VER_digitval[14]);
        timerupdate.restart();
      }
      for (int x = 0; x < 15; x++) {
        receivedChars2[x] = 0;
      }
    }
    if (receivedChars2[3] == '0' && receivedChars2[4] == '5') {
      Serial.println("Got PRO-6");
      if (receivedChars2[7] && receivedChars2[8] && receivedChars2[9] >= 0) {
        GILL_VER_digitval[15] = receivedChars2[7] - '0';
        GILL_VER_digitval[16] = receivedChars2[8] - '0';
        GILL_VER_digitval[17] = receivedChars2[9] - '0';
        Serial.print(GILL_VER_digitval[15]);
        Serial.print(".");
        Serial.print(GILL_VER_digitval[16]);
        Serial.println(GILL_VER_digitval[17]);
        timerupdate.restart();
      }
    }
    if (receivedChars2[3] == '0' && receivedChars2[4] == '6') {
      Serial.println("Got PRO-7");
      if (receivedChars2[7] && receivedChars2[8] && receivedChars2[9] >= 0) {
        GILL_VER_digitval[18] = receivedChars2[7] - '0';
        GILL_VER_digitval[19] = receivedChars2[8] - '0';
        GILL_VER_digitval[20] = receivedChars2[9] - '0';
        Serial.print(GILL_VER_digitval[18]);
        Serial.print(".");
        Serial.print(GILL_VER_digitval[19]);
        Serial.println(GILL_VER_digitval[20]);
        timerupdate.restart();
      }
    }
    if (receivedChars2[3] == '0' && receivedChars2[4] == '7') {
      Serial.println("Got PRO-8");
      if (receivedChars2[7] && receivedChars2[8] && receivedChars2[9] >= 0) {
        GILL_VER_digitval[21] = receivedChars2[7] - '0';
        GILL_VER_digitval[22] = receivedChars2[8] - '0';
        GILL_VER_digitval[23] = receivedChars2[9] - '0';
        Serial.print(GILL_VER_digitval[21]);
        Serial.print(".");
        Serial.print(GILL_VER_digitval[22]);
        Serial.println(GILL_VER_digitval[23]);
        timerupdate.restart();
      }
    }
    if (receivedChars2[3] == '0' && receivedChars2[4] == '8') {
      Serial.println("Got PRO-9");
      if (receivedChars2[7] && receivedChars2[8] && receivedChars2[9] >= 0) {
        GILL_VER_digitval[24] = receivedChars2[7] - '0';
        GILL_VER_digitval[25] = receivedChars2[8] - '0';
        GILL_VER_digitval[26] = receivedChars2[9] - '0';
        Serial.print(GILL_VER_digitval[24]);
        Serial.print(".");
        Serial.print(GILL_VER_digitval[25]);
        Serial.println(GILL_VER_digitval[26]);
        timerupdate.restart();
      }
    }
    if (receivedChars2[3] == '0' && receivedChars2[4] == '9') {
      Serial.println("Got PRO-10");

      if (receivedChars2[7] && receivedChars2[8] && receivedChars2[9] >= 0) {
        GILL_VER_digitval[27] = receivedChars2[7] - '0';
        GILL_VER_digitval[28] = receivedChars2[8] - '0';
        GILL_VER_digitval[29] = receivedChars2[9] - '0';
        Serial.print(GILL_VER_digitval[27]);
        Serial.print(".");
        Serial.print(GILL_VER_digitval[28]);
        Serial.println(GILL_VER_digitval[29]);
        timerupdate.restart();
      }
    }
    for (int x = 0; x < 13; x++) {
      receivedChars2[x] = 0;
    }
    inite = false;
    
    for (int x = 0; x <= 30; x++) {
        if (GILL_VER_digitval[x] != GILL_VER_digitvalold[x]) {
          GILL_VER_digitvalold[x] = GILL_VER_digitval[x];
          giilbarco_data_rec = true;
          gill_update.restart();  // wait for all updates
          Serial.println("NEW PRICES TRIGGERED");
        }
      }
  }
  
}
//==============================  recvWithStartEndMarkers =============================//
void recvWithStartEndMarkers() {
  char hex[5];

  while (GILL_VER_SERIAL.available() > 0) {
    rc = GILL_VER_SERIAL.read();

    sprintf(hex, "%02x ", rc);
    Serial.print(hex);
    //Serial.print(rc, HEX);

    if (rc == startMarker && recvInProgress2 == false) { // rc == 0 for flaky data
      recvInProgress = true;
      recvInProgress2 = true;
      waitingforlrc = false;
      ndx = 0;

      for (int x = 0; x < numChars; x++) {
        receivedChars[x] = 0;
      }
    }
    else if (recvInProgress == true ) {
      digitalWrite(WHITE_LED_POS, HIGH);
      if (rc != endMarker ) {
        receivedChars[ndx] = rc;
        receivedChars2[ndx] = receivedChars[ndx];
        ndx++;
        if (ndx >= numChars) {
          ndx = numChars - 1;
        }
      }
      else {
        Serial.println("ETX");
        receivedChars[ndx] = endMarker; // terminate the string
        ndx++;
        waitingforlrc = true;
        recvInProgress = false;
        digitalWrite(WHITE_LED_POS, LOW);
      }
    }
    else if (waitingforlrc == true) {
      lrc = rc;
      Serial.println("LRC");

      xorTemp = 0;
      for (int i = 0; i < ndx; i++) {
        sprintf(hex, "%02x ", receivedChars[i]);
        Serial.print(hex);
        xorTemp ^= (byte)receivedChars[i];

      }
      Serial.println("");
      Serial.print("The checksum equals ");
      Serial.println(xorTemp, HEX);
      Serial.println("");
      Serial.print("The LRC equals ");
      Serial.println(lrc, HEX);
      Serial.println("");

      if (lrc == xorTemp) {
        //newData = false;
      showNewData();
        Serial.println("SENT NEW DATA");
      }
      else {
        GILL_VER_SERIAL.write(nak);
        Serial.println("SENT NAK");
      }

      waitingforlrc = false;
      recvInProgress2 = false;
    }
    else {
      Serial.print("unexpected data ");
      sprintf(hex, "%02x ", rc);
      Serial.println(hex);
    }
  }
}
void data_update()
{
  String inputMessage4;
  price_grade1 = digitval[0]*100 + digitval[1]*10 + digitval[2];
  inputMessage4 = price_grade1;
  writeFile(SPIFFS, "/price_grade1.txt", inputMessage4.c_str());
  price_grade2 = digitval[3]*100 + digitval[4]*10 + digitval[5] ;
  inputMessage4 = price_grade2;
  writeFile(SPIFFS, "/price_grade2.txt", inputMessage4.c_str());
  price_grade3 = digitval[6]*100 + digitval[7]*10 + digitval[8] ;
  inputMessage4 = price_grade3;
  writeFile(SPIFFS, "/price_grade3.txt", inputMessage4.c_str());
  price_grade4 = digitval[9]*100 + digitval[10]*10 + digitval[11] ;
  inputMessage4 = price_grade4;
  writeFile(SPIFFS, "/price_grade4.txt", inputMessage4.c_str());
  price_grade5 = digitval[12]*100 + digitval[13]*10 + digitval[14] ;
  inputMessage4 = price_grade5;
  writeFile(SPIFFS, "/price_grade5.txt", inputMessage4.c_str());
  price_grade6 = digitval[15]*100 + digitval[16]*10 + digitval[17] ;
  inputMessage4 = price_grade6;
  writeFile(SPIFFS, "/price_grade6.txt", inputMessage4.c_str());
  price_grade7 = digitval[18]*100 + digitval[19]*10 + digitval[20] ;
  inputMessage4 = price_grade7;
  writeFile(SPIFFS, "/price_grade7.txt", inputMessage4.c_str());
  price_grade8 = digitval[21]*100 + digitval[22]*10 + digitval[23] ;
  inputMessage4 = price_grade8;
  writeFile(SPIFFS, "/price_grade8.txt", inputMessage4.c_str());
  price_grade9 = digitval[24]*100 + digitval[25]*10 + digitval[26] ;
  inputMessage4 = price_grade9;
  writeFile(SPIFFS, "/price_grade9.txt", inputMessage4.c_str());
  price_grade10 = digitval[27]*100 + digitval[28]*10 + digitval[29] ;
  inputMessage4 = price_grade10;
  writeFile(SPIFFS, "/price_grade10.txt", inputMessage4.c_str());
  price_grade11 = digitval[30]*100 + digitval[31]*10 + digitval[32] ;
  inputMessage4 = price_grade11;
  writeFile(SPIFFS, "/price_grade11.txt", inputMessage4.c_str());
  price_grade12 = digitval[33]*100 + digitval[34]*10 + digitval[35] ;
  inputMessage4 = price_grade12;
  writeFile(SPIFFS, "/price_grade12.txt", inputMessage4.c_str());
  price_grade13 = digitval[36]*100 + digitval[37]*10 + digitval[38] ;
  inputMessage4 = price_grade13;
  writeFile(SPIFFS, "/price_grade13.txt", inputMessage4.c_str());
  price_grade14 = digitval[39]*100 + digitval[40]*10 + digitval[41] ;
  inputMessage4 = price_grade14;
  writeFile(SPIFFS, "/price_grade14.txt", inputMessage4.c_str());
  price_grade15 = digitval[42]*100 + digitval[43]*10 + digitval[44] ;
  inputMessage4 = price_grade15;
  writeFile(SPIFFS, "/price_grade15.txt", inputMessage4.c_str());
  price_grade16 = digitval[45]*100 + digitval[46]*10 + digitval[47] ;
  inputMessage4 = price_grade16;
  writeFile(SPIFFS, "/price_grade16.txt", inputMessage4.c_str());
  Serial.println("Veriphone/HMI data_updated");

  //testing
  Serial.print("price_grade1");
  Serial.println(price_grade1);
  Serial.print("price_grade2");
  Serial.println(price_grade2);
  Serial.print("price_grade3");
  Serial.println(price_grade3);
  Serial.print("price_grade4");
  Serial.println(price_grade4);
  Serial.print("price_grade5");
  Serial.println(price_grade5);
  Serial.print("price_grade6");
  Serial.println(price_grade6);
  Serial.print("price_grade7");
  Serial.println(price_grade7);
  Serial.print("price_grade8");
  Serial.println(price_grade8);
  Serial.print("price_grade9");
  Serial.println(price_grade9);
  Serial.print("price_grade10");
  Serial.println(price_grade10);
  Serial.print("price_grade11");
  Serial.println(price_grade11);
  Serial.print("price_grade12");
  Serial.println(price_grade12);
  Serial.print("price_grade13");
  Serial.println(price_grade13);
  Serial.print("price_grade14");
  Serial.println(price_grade14);
  Serial.print("price_grade15");
  Serial.println(price_grade15);
  Serial.print("price_grade16");
  Serial.println(price_grade16);
}
int HexDigit(unsigned char c)
{
  if (c >= '0' && c <= '9')
    return c - '0';

  if (c >= 'A' && c <= 'F')
    return c - 'A' + 10;

  if (c >= 'a' && c <= 'f')
    return c - 'a' + 10;

  return 0;
}

char HexByte(char *p)
{
  char value = 0;

  value += HexDigit(*p++);

  if (*p != '\0')
  {
    value = value * 16 +  HexDigit(*p);
  }
  return value;
}
//============================== hmi_data_value_update =============================//
void hmi_data_value_update()
{
  if(hmi_cash_price == true)
  {
    hmi_cash_price = false;
    if(num_of_groups == 4)
    {
      price_digit1 = data_value[0];
      price_digit2 = data_value[1];
      price_digit3 = data_value[2];
      price_digit4 = data_value[3];
      price_digit5 = data_value[4];
      price_digit6 = data_value[5];
      price_digit7 = data_value[6];
      price_digit8 = data_value[7];
      price_digit9 = data_value[8];
      price_digit10 = data_value[9];
      price_digit11 = data_value[10];
      price_digit12 = data_value[11];
      Serial.print("grade 4 cash");
    }
    else if(num_of_groups == 5)
    {
      price_digit1 = data_value[0];
      price_digit2 = data_value[1];
      price_digit3 = data_value[2];
      price_digit4 = data_value[3];
      price_digit5 = data_value[4];
      price_digit6 = data_value[5];
      price_digit7 = data_value[6];
      price_digit8 = data_value[7];
      price_digit9 = data_value[8];
      price_digit10 = data_value[9];
      price_digit11 = data_value[10];
      price_digit12 = data_value[11];
      price_digit13 = data_value[12];
      price_digit14 = data_value[13];
      price_digit15 = data_value[14];
      Serial.print("grade 5 cash");
    }
    else if(num_of_groups == 6) 
    {
      price_digit1 = data_value[0];
      price_digit2 = data_value[1];
      price_digit3 = data_value[2];
      price_digit4 = data_value[3];
      price_digit5 = data_value[4];
      price_digit6 = data_value[5];
      price_digit7 = data_value[6];
      price_digit8 = data_value[7];
      price_digit9 = data_value[8];
      price_digit10 = data_value[9];
      price_digit11 = data_value[10];
      price_digit12 = data_value[11];
      price_digit13 = data_value[12];
      price_digit14 = data_value[13];
      price_digit15 = data_value[14];
      price_digit16 = data_value[15];
      price_digit17 = data_value[16];
      price_digit18 = data_value[17];
      Serial.print("grade 6 cash");
    }
    else if(num_of_groups == 7) 
    {
      price_digit1 = data_value[0];
      price_digit2 = data_value[1];
      price_digit3 = data_value[2];
      price_digit4 = data_value[3];
      price_digit5 = data_value[4];
      price_digit6 = data_value[5];
      price_digit7 = data_value[6];
      price_digit8 = data_value[7];
      price_digit9 = data_value[8];
      price_digit10 = data_value[9];
      price_digit11 = data_value[10];
      price_digit12 = data_value[11];
      price_digit13 = data_value[12];
      price_digit14 = data_value[13];
      price_digit15 = data_value[14];
      price_digit16 = data_value[15];
      price_digit17 = data_value[16];
      price_digit18 = data_value[17];
      price_digit19 = data_value[18];
      price_digit20 = data_value[19];
      price_digit21 = data_value[20];
      Serial.print("grade 7 cash");
    }
    else
    {
      price_digit1 = data_value[0];
      price_digit2 = data_value[1];
      price_digit3 = data_value[2];
      price_digit4 = data_value[3];
      price_digit5 = data_value[4];
      price_digit6 = data_value[5];
      price_digit7 = data_value[6];
      price_digit8 = data_value[7];
      price_digit9 = data_value[8];
      price_digit10 = data_value[9];
      price_digit11 = data_value[10];
      price_digit12 = data_value[11];
      price_digit13 = data_value[12];
      price_digit14 = data_value[13];
      price_digit15 = data_value[14];
      price_digit16 = data_value[15];
      price_digit17 = data_value[16];
      price_digit18 = data_value[17];
      price_digit19 = data_value[18];
      price_digit20 = data_value[19];
      price_digit21 = data_value[20];
      price_digit22 = data_value[21];
      price_digit23 = data_value[22];
      price_digit24 = data_value[23];
      Serial.print("grade 8 cash");
    }
    

    for(int j=0; j<(num_of_groups * 3); j++)
    {
     // hmi_price_digit[(j*2)]=data_value[j];
      digitval[j] = data_value[j];
    }
    Serial.println("hmi cash price storing");
  }
  if(hmi_credit_price == true)
  {
    hmi_credit_price = false;
    if(num_of_groups == 4)
    {
      price_digit13 = data_value[12];
      price_digit14 = data_value[13];
      price_digit15 = data_value[14];
      price_digit16 = data_value[15];
      price_digit17 = data_value[16];
      price_digit18 = data_value[17];
      price_digit19 = data_value[18];
      price_digit20 = data_value[19];
      price_digit21 = data_value[20];
      price_digit22 = data_value[21];
      price_digit23 = data_value[22];
      price_digit24 = data_value[23];
      Serial.print("grade 4 credit");
    }
    else if(num_of_groups == 5)
    {
      price_digit16 = data_value[15];
      price_digit17 = data_value[16];
      price_digit18 = data_value[17];
      price_digit19 = data_value[18];
      price_digit20 = data_value[19];
      price_digit21 = data_value[20];
      price_digit22 = data_value[21];
      price_digit23 = data_value[22];
      price_digit24 = data_value[23];
      price_digit25 = data_value[24];
      price_digit26 = data_value[25];
      price_digit27 = data_value[26];
      price_digit28 = data_value[27];
      price_digit29 = data_value[28];
      price_digit30 = data_value[29];
      Serial.print("grade 5 credit");
    }
    else if(num_of_groups == 6)
    {
      price_digit19 = data_value[18];
      price_digit20 = data_value[19];
      price_digit21 = data_value[20];
      price_digit22 = data_value[21];
      price_digit23 = data_value[22];
      price_digit24 = data_value[23];
      price_digit25 = data_value[24];
      price_digit26 = data_value[25];
      price_digit27 = data_value[26];
      price_digit28 = data_value[27];
      price_digit29 = data_value[28];
      price_digit30 = data_value[29];
      price_digit31 = data_value[30];
      price_digit32 = data_value[31];
      price_digit33 = data_value[32];
      price_digit34 = data_value[33];
      price_digit35 = data_value[34];
      price_digit36 = data_value[35];
      Serial.print("grade 6 credit");
    }
    else if(num_of_groups == 7)
    {
      price_digit22 = data_value[21];
      price_digit23 = data_value[22];
      price_digit24 = data_value[23];
      price_digit25 = data_value[24];
      price_digit26 = data_value[25];
      price_digit27 = data_value[26];
      price_digit28 = data_value[27];
      price_digit29 = data_value[28];
      price_digit30 = data_value[29];
      price_digit31 = data_value[30];
      price_digit32 = data_value[31];
      price_digit33 = data_value[32];
      price_digit34 = data_value[33];
      price_digit35 = data_value[34];
      price_digit36 = data_value[35];
      price_digit37 = data_value[36];
      price_digit38 = data_value[37];
      price_digit39 = data_value[38];
      price_digit40 = data_value[39];
      price_digit41 = data_value[40];
      price_digit42 = data_value[41];
      Serial.print("grade 7 credit");
    }
    else if(num_of_groups == 8)
    {
      price_digit25 = data_value[24];
      price_digit26 = data_value[25];
      price_digit27 = data_value[26];
      price_digit28 = data_value[27];
      price_digit29 = data_value[28];
      price_digit30 = data_value[29];
      price_digit31 = data_value[30];
      price_digit32 = data_value[31];
      price_digit33 = data_value[32];
      price_digit34 = data_value[33];
      price_digit35 = data_value[34];
      price_digit36 = data_value[35];
      price_digit37 = data_value[36];
      price_digit38 = data_value[37];
      price_digit39 = data_value[38];
      price_digit40 = data_value[39];
      price_digit41 = data_value[40];
      price_digit42 = data_value[41];
      price_digit43 = data_value[42];
      price_digit44 = data_value[43];
      price_digit45 = data_value[44];
      price_digit46 = data_value[45];
      price_digit47 = data_value[46];
      price_digit48 = data_value[47];
      Serial.print("grade 8 credit");
    }
    int temp_j_start = (num_of_groups * 3),temp_j_stop = (num_of_groups * 3 *2);
    Serial.print("temp_j_start");
     Serial.print(temp_j_start);
    Serial.print("temp_j_stop");
    Serial.print(temp_j_stop);
    for(int j=temp_j_start; j < temp_j_stop; j++) //for grade selection
    {
     // hmi_price_digit[(j*2)]=data_value[j];
      digitval[j] = data_value[j];
    }
    Serial.println("hmi credit price storing");
  }
  /*
  // =========================== MESH PRICE TRANSMIT =============================//
    String sync;
    for (int i = 0; i < 36; i++)
    {
      sync += digits[i] + "," + String(digitval[i]) + ",";
      yield();
    }
    Serial.println(sync);
    mesh.sendBroadcast(sync);
    taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
    Serial.println("sync MSG SENDING FROM DATA UPDATE");
  */
  data_update();  //saving in grade values
}
//------------------------------ HMI FUNCTION hmi_read_data_check --------------------------//
void hmi_read_data_check(unsigned long addre)
{
  String inputMessage3;
  Serial.print("hmi_read_data_check = ");
  Serial.print(addre);
  switch (addre) 
  {
    case 0x00080002:
      // READ AND UPDATE  CASH PRICE
      
      for (int j = (0); j < (data_length); j++) 
      {
        data_value[j] = hmi.__find_data(&hmi_data_recieve[0],data_st_byte, j+1);
        //Serial.print("data_value");
        Serial.println(data_value[j]);
      }
      
      hmi_cash_price = true;  //cash price recieved
      intermediator_price_update = true;  //data data_transmit_rf 
      if(data_length >= 18)
      {
        price_grade_1_update = true;
        price_grade_2_update = true;
        price_grade_3_update = true;
        price_grade_4_update = true;
        price_grade_5_update = true;
        price_grade_6_update = true;
        price_grade_7_update = true;
        price_grade_8_update = true;
      }
      hmi_data_value_update();
      Serial.print("HMI CASH PRICE RECIEVED");
    break;
    case 0x00080034:
      //READ AND UPDATE CREDIT PRICE
      for (int j = (0); j < ((data_length)); j++) 
      {
        data_value[(j+(num_of_groups * 3))] = hmi.__find_data(&hmi_data_recieve[0],data_st_byte, j+1);
        //Serial.print("data_value");
        Serial.println(data_value[(j+(num_of_groups * 3))]);
      }
      
      hmi_credit_price = true;  //credit recieved
      intermediator_price_update = true;  //data data_transmit_rf 
      if(data_length >= 18)
      {
        price_grade_5_update = true;
        price_grade_6_update = true;
        price_grade_7_update = true;
        price_grade_8_update = true;
        price_grade_9_update = true;
        price_grade_10_update = true;
        price_grade_11_update = true;
        price_grade_12_update = true;
        price_grade_13_update = true;
        price_grade_14_update = true;
        price_grade_15_update = true;
        price_grade_16_update = true;
      }
      hmi_data_value_update();
      Serial.print("HMI CREDIT PRICE RECIEVED");
    break;
    case 0x00087010:
      //READ AND UPDATE CDC ON VARIABLE
      
      flash_time = hmi.__find_data(&hmi_data_recieve[0],data_st_byte, 1);  //DWELLING TIME
      inputMessage3 = flash_time;
      writeFile(SPIFFS, "/flash_time.txt", inputMessage3.c_str());
      Serial.print("flash_TIME UPDATED = ");
      Serial.println(flash_time);
      Serial.print("flash_style UPDATED = ");
      Serial.println(flash_style);
      CDC_update = 1; //cdc recieved
      cdc_RF_update = true;
      //Advanced_RF_update = true;//TEMP
      con_cash = 1, con_debit = 1, con_credit = 1;

      flashing = 1;
      Serial.println("HMI CDC ON UPDATED");
    break; 
    case 0x00087004:
      //READ AND UPDATE CDC OFF VARIABLE
      con_cash = hmi.__find_data(&hmi_data_recieve[0],data_st_byte, 1);  //CASH
      inputMessage3 = con_cash;
      writeFile(SPIFFS, "/con_cash.txt", inputMessage3.c_str());
      con_debit = hmi.__find_data(&hmi_data_recieve[0],data_st_byte, 2);  //DEBIT
      inputMessage3 = con_debit;
      writeFile(SPIFFS, "/con_debit.txt", inputMessage3.c_str());
      con_credit = hmi.__find_data(&hmi_data_recieve[0],data_st_byte, 3);  //CREDIT
      inputMessage3 = con_credit;
      writeFile(SPIFFS, "/con_credit.txt", inputMessage3.c_str());
      CDC_update = 1; //cdc recieved
      cdc_RF_update = true;
      flashing = 0;
      Serial.println("HMI CDC OFF UPDATED");
    break;
    case 0x00086002:
        data_num = 1;
        data_st_byte = 2;//PAGE ID RESPONSE
        Brightness = hmi.__find_data(&hmi_data_recieve[0],data_st_byte, 1);
        inputMessage3 = Brightness;
        //TEMP//setBrightness(Brightness);
        writeFile(SPIFFS, "/Brightvalue.txt", inputMessage3.c_str());
        brightness_update = true;
        Serial.print("HMI Brightness UPDATED = ");
        Serial.println(Brightness);
        data_recieve_app();
    break;
  }
  /*
  for (int j = (0+start_data_address); j < (data_length); j++) 
  {
    data_value[j] = hmi.__find_data(&hmi_data_recieve[0],data_st_byte, j+1);
    //Serial.print("data_value");
    Serial.println(data_value[j]);
  }
  hmi_data_value_update();*/
}
//--------------------------------- HMI hmi_address_check -------------------------------//
void hmi_address_check(unsigned long address)
{
  String inputMessage4;
  Serial.print("page_id = ");
  Serial.println(page_id);
  Serial.print("address_id = ");
  Serial.println(address,  HEX);
  switch (address) 
  {
      case 0x00089100:  //UPDATE BUTTON RESPONSE
      //Read price digit value  
      Serial.println("update button pressed "); 
      if(((page_id >=16) && (page_id <= 21)) || (page_id == 77) || (page_id == 78) || (page_id == 81))
      {
        Serial.println(" Read cash price ");
        hmi.HMT_Successive_ReadNumVp(0x00080002, 24);
      }
      else if(((page_id >=22) && (page_id <=27)) || (page_id == 79) || (page_id == 80) || (page_id == 82))
      {
        Serial.println(" Read credit price ");
        hmi.HMT_Successive_ReadNumVp(0x00080034, 24);
      } 
      break;
      case 0x00088000:  //price changer click
        //show page based on grade number and cash credit on/off
        Serial.println("price changer click ");
        Serial.println(G_CASH_ID[(num_of_groups-1)]);
        hmi.HMT_DispPage(G_CASH_ID[(num_of_groups-1)]);
        page_id = G_CASH_ID[(num_of_groups-1)];
        price_change = true;  //to write in hmi
        rf_price_transmit = true;// to stop price transmit on price display on hmi
        data_recieve_app();
        hmi_price_value_update();
        if(SLEEP_MODE == false)
        {
          hmi.HMT_Successive_WriteNumVp(0x00080002,24,&hmi_price_digit_g[0]);
          hmi.HMT_Successive_WriteNumVp(0x00080034,24,&hmi_price_digit_g[48]);
        //write old data into hmi 
        }
        else
        {
          hmi.HMT_Successive_WriteNumVp(0x00080002,24,&hmi_sleep_digit[0]);
          hmi.HMT_Successive_WriteNumVp(0x00080034,24,&hmi_sleep_digit[48]);
        //write old data into hmi
        }

        // write grade names
        for(int j = 1; j <= 16; j++)
        {
          int k;
          disp_g_name = G_NAME[j];
          Serial.print(disp_g_name_num[j-1]);
          Serial.print("disp_g_name");
          Serial.println(G_NAME[j]);
          disp_g_name_length =  disp_g_name.length();
          disp_g_name.toCharArray(disp_g_name_buff, disp_g_name.length() + 1);
          for (unsigned i = 0; i < (disp_g_name_length); i ++)
          {
            disp_gbuffer[i] = (disp_g_name_buff[i]);
          }
          disp_gbuffer[disp_g_name_length] = 0x00;
          if(j> num_of_groups)
          {
            k = (j + (8-num_of_groups));
            hmi.HMT_WirteVPString(disp_g_name_num[k-1], &disp_gbuffer[0]);
          }
          else
          {
            hmi.HMT_WirteVPString(disp_g_name_num[j-1], &disp_gbuffer[0]);
          }
          
        }
      break;
      case 0x00080100:  //price changer click
        //show page based on grade number and cash credit on/off.
        if(group_type != 0)
        {
          Serial.println("CASH TO CREDIT click ");
        hmi.HMT_DispPage(G_CREDIT_ID[(num_of_groups-1)]);
        page_id = G_CREDIT_ID[(num_of_groups-1)];
        //hmi.HMT_Successive_WriteNumVp(0x0034,18,&hmi_price_digit[37]);
        }
      break;
      case 0x00080102:  //price changer click
        //show page based on grade number and cash credit on/off
        Serial.println("CREDIT TO CASH click ");
        hmi.HMT_DispPage(G_CASH_ID[(num_of_groups-1)]);
        page_id = G_CASH_ID[(num_of_groups-1)];
        //hmi.HMT_Successive_WriteNumVp(0x00080002,18,&hmi_price_digit[0]);
      break;  
      case 0x00080104:  //sleep mode
        Serial.println("SLEEP MODE CHANGE ");
        SLEEP_MODE = touch_data;
        if(SLEEP_MODE == true)
        {
          Serial.println("SLEEP MODE ON ");
          sendCDC_INTERMEDIATOR(19,SLEEP_MODE);
          hmi.HMT_Successive_WriteNumVp(0x00080002,24,&hmi_sleep_digit[0]);
          hmi.HMT_Successive_WriteNumVp(0x00080034,24,&hmi_sleep_digit[48]);
          String selected_sleepmode = "SLEEP," + String(1) + "," ;
          mesh.sendBroadcast(selected_sleepmode);
          taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
        else
        {
          price_change = true;  //to write in hmi
          rf_price_transmit = true;// to stop price transmit on price display on hmi
          data_recieve_app();
          hmi_price_value_update();
          Serial.println("SLEEP MODE OFF ");
          hmi.HMT_Successive_WriteNumVp(0x00080002,24,&hmi_price_digit_g[0]);
          hmi.HMT_Successive_WriteNumVp(0x00080034,24,&hmi_price_digit_g[48]);
          sendCDC_INTERMEDIATOR(19,SLEEP_MODE);
          String selected_sleepmode = "SLEEP," + String(0) + "," ;
          mesh.sendBroadcast(selected_sleepmode);
          taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
      break;
      case 0x00080106:  //price changer click
        //show page based on grade number and cash credit remaining grades
        Serial.println("CASH MORE GRADES SHOW");
        if(num_of_groups == 7)
        {
          hmi.HMT_DispPage(77);
          page_id = 77;
        }
        else if(num_of_groups == 8)
        {
          hmi.HMT_DispPage(78);
          page_id = 78;
        }
        //hmi.HMT_Successive_WriteNumVp(0x00080002,18,&hmi_price_digit[0]);
      break; 
      case 0x00080108:  //price changer click
        //show page based on grade number and cash credit remaining grades
        if(num_of_groups == 7)
        {
          hmi.HMT_DispPage(79);
          page_id = 79;
        }
        else if(num_of_groups == 8)
        {
          hmi.HMT_DispPage(80);
          page_id = 80;
        }
      break; 
      case 0x00088004:  // brightness setting page click 
        // Read brightness value
        hmi.HMT_WriteVPN16(0x00086002, Brightness);
        hmi.HMT_SendCMD_ReadPageID();
        Serial.println("brightness setting ");
      break;
      case 0x00088002:  //setting page click
      case 0x00088006:   // tutorial setting page click 
      case 0x00088008:   //visit us setting page click 
      case 0x00088010:   //add device setting page click
      case 0x00088012:   //my device setting page click 
      case 0x00088014:   //alternate price setting page click
      case 0x00088016:   //ota update setting page click 
        // Read page id from device
        Serial.println("page clicked ");
        hmi.HMT_SendCMD_ReadPageID();
      break;
      case 0x00087100:   //alternate price (CDC ON) UPDATRE BUTTON
        //Read CDC ON
        Serial.println("CDC ON update ");
        hmi.HMT_WirteVPString(0x00001380, &SUCCESSFULL[0]);
        hmi.HMT_Successive_ReadNumVp(0x00087010, 2);
      break;
      case 0x00087012:   //alternate price (CDC ON) LEVEL STATUS CDC
        //Read CDC ON
        Serial.println("CDC ON LEVEL SET ");
        if(touch_data == 0x01)
        {
          flash_style = 1;  //PRICE LEVEL
          inputMessage4 = flash_style;
          writeFile(SPIFFS, "/flash_style.txt", inputMessage4.c_str());
          hmi.HMT_WirteVPString(0x00001300, &CDC_LEVEL_1[0]);
          
        }
        else if(touch_data == 0x02)
        {
          flash_style = 2;  //PRICE LEVEL
          inputMessage4 = flash_style;
          writeFile(SPIFFS, "/flash_style.txt", inputMessage4.c_str());
          hmi.HMT_WirteVPString(0x00001300, &CDC_LEVEL_2[0]);
        }
        else if(touch_data == 0x03)
        {
          flash_style = 3;  //PRICE LEVEL
          inputMessage4 = flash_style;
          writeFile(SPIFFS, "/flash_style.txt", inputMessage4.c_str());
          hmi.HMT_WirteVPString(0x00001300, &CDC_LEVEL_3[0]);
        }
        else if(touch_data == 0x04)
        {
          flash_style = 4;  //PRICE LEVEL
          inputMessage4 = flash_style;
          writeFile(SPIFFS, "/flash_style.txt", inputMessage4.c_str());
          hmi.HMT_WirteVPString(0x00001300, &CDC_LEVEL_4[0]);
        }
        else if(touch_data == 0x05)
        {
          flash_style = 5;  //PRICE LEVEL
          inputMessage4 = flash_style;
          writeFile(SPIFFS, "/flash_style.txt", inputMessage4.c_str());
          hmi.HMT_WirteVPString(0x00001300, &CDC_LEVEL_5[0]);
        }
      break;
      case 0x00087102:   //alternate price (CDC OFF) UPDATRE BUTTON
        //Read CDC OFF
        Serial.println("CDC OFF update ");
        hmi.HMT_Successive_ReadNumVp(0x00087004, 3);
      break;
      case 0x00084002:   //no. of grades to display IN FULL SITE
        //Read no. of grades in RF environment
        Serial.println("num_of_groups set ");
        num_of_groups = touch_data;
        gill_update.restart();
      break;
      case 0x00084000:   //no. of grades to display submit permanent
        //set  no. of grades in RF environment
        Serial.println("num_of_groups set update ");
        inputMessage4 = num_of_groups;
        writeFile(SPIFFS, "/num_of_groups.txt", inputMessage4.c_str());
        hmi.HMT_WriteVPN16(0x00084050,num_of_groups);
        hmi.HMT_DispPage(33); //RF HOME PAGE
        
      break;
      case 0x00081000:   //GRADE1 NUM ALLOCATE
        G_NUM_ALLOC[0] = touch_data;
        Serial.print(" 1 GRADE SELECTION NUMBER IS = " );
        Serial.println(G_NUM_ALLOC[0]);
      break;
      case 0x00081002:   //GRADE2 NUM ALLOCATE
        G_NUM_ALLOC[1] = touch_data;
        Serial.print(" 2 GRADE SELECTION NUMBER IS = " );
        Serial.println(G_NUM_ALLOC[1]);
      break;
      case 0x00081004:   //GRADE3 NUM ALLOCATE
        G_NUM_ALLOC[2] = touch_data;
        Serial.print(" 3 GRADE SELECTION NUMBER IS = " );
        Serial.println(G_NUM_ALLOC[2]);
      break;
      case 0x00081006:   //GRADE4 NUM ALLOCATE
        G_NUM_ALLOC[3] = touch_data;
        Serial.print(" 4 GRADE SELECTION NUMBER IS = " );
        Serial.println(G_NUM_ALLOC[3]);
      break;
      case 0x00081008:   //GRADE5 NUM ALLOCATE
        G_NUM_ALLOC[4] = touch_data;
        Serial.print(" 5 GRADE SELECTION NUMBER IS = " );
        Serial.println(G_NUM_ALLOC[4]);
      break;
      case 0x0008100A:   //GRADE6 NUM ALLOCATE
        G_NUM_ALLOC[5] = touch_data;
        Serial.print(" 6 GRADE SELECTION NUMBER IS = " );
        Serial.println(G_NUM_ALLOC[5]);
      break;
      case 0x00081014:   //GRADE7 NUM ALLOCATE
        G_NUM_ALLOC[6] = touch_data;
        Serial.print(" 7 GRADE SELECTION NUMBER IS = " );
        Serial.println(G_NUM_ALLOC[6]);
      break;
      case 0x00081016:   //GRADE8 NUM ALLOCATE
        G_NUM_ALLOC[7] = touch_data;
        Serial.print(" 8 GRADE SELECTION NUMBER IS = " );
        Serial.println(G_NUM_ALLOC[7]);
      break;
      case 0x0008100C:   //SEND ALLOCATED GRADE NUM TO BOARDS
        Serial.print(" SEND GRADE CONTROL NUMBERS" );
        for(int i = 0; i <= 7; i++)
        {
          sendCommand((51+i), 7, G_NUM_ALLOC[i]);
        }
      break;
      case 0x00081010:   //SEND ALLOCATED GRADE NUM TURN ON
        Serial.print(" GRADE SELECTION TURN ON" );
        sendCDC_INTERMEDIATOR(14,1);
        RESET_DEVICES();
        hmi.HMT_DispPage(5);
      break;
      case 0x00081018:   //MASTER & SECONDARY ALLOCATE
        Master_sec_board = touch_data;
        Serial.print(" Master_sec_board IS = " );
        Serial.println(Master_sec_board);
        if(Master_sec_board == 1)
        {
          hmi.HMT_WirteVPString(0x00002500, &MASTER[0]);
        }
        else
        {
          hmi.HMT_WirteVPString(0x00002500, &SECONDARY[0]);
        }
      break;
      case 0x0008101A:   //TOTAL GRADES IN ENVIRONMENT
        Max_grade_env = touch_data;
        Serial.print(" Max_grade_env NUMBER IS = " );
        Serial.println(Max_grade_env);
      break;
      case 0x0008101C:   //UPDATE AND NEXT MASTER GRADE SELECT
        Serial.print(" UPDATE AND NEXT GRADE ORDER SELECT 1" );
        sendCDC_INTERMEDIATOR(15,Max_grade_env);
        sendCDC_INTERMEDIATOR(16,Master_sec_board);
        hmi.HMT_DispPage(70);
      break;
      case 0x0008101E:   //SEND ALLOCATED GRADE NUM TO BOARDS
        Serial.print(" SEND GRADE ORDER DISPLAY" );
        sendCDC_INTERMEDIATOR(17,1);
      break;
      case 0x00081020:   //TOTAL GRADES IN ENVIRONMENT
        Gillbarco_setup = touch_data;
        sendCDC_INTERMEDIATOR(18,Gillbarco_setup);
        Serial.print(" Gillbarco_setup IS = " );
        Serial.println(Gillbarco_setup);
      break;
      case 0x00081022:   //GRADE CONTROL ON OFF SET
        Grade_control_setup = touch_data; 
        
        if(Grade_control_setup == 1)
        {
          hmi.HMT_WirteVPString(0x00003200, &ON[0]);
        }
        else
        {
          hmi.HMT_WirteVPString(0x00003200, &OFF[0]);
        }
        
      break;
      case 0x00081024:   //GRADE CONTROL ON OFF UPDATE
        sendCDC_INTERMEDIATOR(20,Grade_control_setup);
        Serial.print(" Grade_control_setup SEND = " );
        Serial.println(Grade_control_setup);
      break;
      case 0x00081026:   //GRADE CONTROL ON OFF UPDATE
        Channel_control_setup = touch_data;
        sendCDC_INTERMEDIATOR(21,Channel_control_setup);
        Serial.print(" Channel_control_setup SEND = " );
        Serial.println(Channel_control_setup);
      break;
      case 0x00087104:   //RF CHANNEL NUMBER SELECTION TO COMMUNICATE
        master_RF_channel_num = touch_data;
        Serial.print(" RF CHANNEL NUMBER SELECTION IS = " );
        Serial.println(master_RF_channel_num);
      break;
      case 0x00087106:   //SEND SELECTED RF CHANNEL TO DEVICES
        //set RF CHANNEL no.  in RF environment
        Serial.println(" SENT RF CHANNEL NUMBER " );
        Serial.println(master_RF_channel_num);
        sendCDC_INTERMEDIATOR(7,master_RF_channel_num);
      break;
      case 0x00087108:   //SAVE SELECTED MASTER RF CHANNEL
        //set RF CHANNEL no.  in RF environment
        Serial.println(" SAVE MASTER RF CHANNEL NUMBER " );
        Serial.println(master_RF_channel_num);
        inputMessage4 = master_RF_channel_num;
        writeFile(SPIFFS, "/master_RF_channel_num.txt", inputMessage4.c_str());
        sendCDC_INTERMEDIATOR(8,master_RF_channel_num);
      break;
      case 0x0008710A:   //SECONDARY RF CHANNEL NUMBER SELECTION TO COMMUNICATE
        secondary_RF_channel_num = touch_data;
        Serial.print(" SECONDARY RF CHANNEL NUMBER SELECTION IS = " );
        Serial.println(secondary_RF_channel_num);
      break;
      case 0x0008710C:   //SEND SELECTED RF CHANNEL TO DEVICES
        //set secondary RF CHANNEL no.  in RF environment
        Serial.println(" SECONDARY SENT RF CHANNEL NUMBER " );
        Serial.println(secondary_RF_channel_num);
        sendCDC_INTERMEDIATOR(9,secondary_RF_channel_num);
      break;
      case 0x0008710E:   //SAVE SELECTED secondary RF CHANNEL
        //set RF CHANNEL no.  in RF environment
        Serial.println(" SAVE SECONDARY RF CHANNEL NUMBER " );
        Serial.println(secondary_RF_channel_num);
        inputMessage4 = secondary_RF_channel_num;
        writeFile(SPIFFS, "/secondary_RF_channel_num.txt", inputMessage4.c_str());
        sendCDC_INTERMEDIATOR(10,secondary_RF_channel_num);
      break;
      case 0x00087208:   //SEND SELECTED RF CHANNEL TO DEVICES
        Serial.println(" STARTING LOOP TO SEND DISPLAY RF CHANNEL " );
        hmi.HMT_WirteVPString(0x00002480, &WAIT[0]);
        for(int i = 0; i <= 17; i++)
        {
          SECONDARY_channel_RF = i;
          iport_r();
          sendCDC_INTERMEDIATOR(11,secondary_RF_channel_num);
        }
        iport_s();
        Serial2.flush();
        hmi.HMT_WriteVPN16(0x0008720E,MASTER_channel_RF);
        hmi.HMT_WirteVPString(0x00002480, &DONE[0]);
      break;
      case 0x0008730A:   //SEND SELECTED RF CHANNEL TO DEVICES
        Serial.println(" SHOW HMI RF CHANNEL " );
        hmi.HMT_WriteVPN16(0x0008720E,MASTER_channel_RF);
      break;
      case 0x00087304:   //SEND SELECTED RF CHANNEL TO DEVICES
        hmi.HMT_WriteVPN16(0x00087302,0);
        hmi.HMT_WirteVPString(0x00002380, &WAIT[0]);
        Serial.println(" SHOW REMOTE  RF CHANNEL " );
        for(int i = 0; i <= 17; i++)
        {
          SECONDARY_channel_RF = i;
          iport_r();
          sendCDC_INTERMEDIATOR(13,MASTER_channel_RF);
        }
        iport_s();
        Serial2.flush();
        hmi.HMT_WirteVPString(0x00002380, &DONE[0]);
      break;
      case 0x00087308:
        hmi.HMT_WriteVPN16(0x00087306,value);
        hmi.HMT_WirteVPString(0x00002400, &WAIT[0]);
        Serial.println(" SHOW POS RF CHANNEL " );
        for(int i = 0; i <= 17; i++)
        {
          SECONDARY_channel_RF = i;
          iport_r();
          sendCDC_INTERMEDIATOR(13,MASTER_channel_RF);
        }
        iport_s();
        Serial2.flush();
        hmi.HMT_WirteVPString(0x00002400, &DONE[0]);
      break;
      case 0x0008720A:   //HMI RF CHANNEL NUMBER SELECTION TO COMMUNICATE
        master_RF_channel_num = touch_data;
        Serial.print(" RF CHANNEL NUMBER SELECTION IS = " );
        Serial.println(master_RF_channel_num);
      break;
      case 0x0008720C:   //HMI SAVE SELECTED MASTER RF CHANNEL
        Serial.println(" SAVE HMI RF CHANNEL NUMBER " );
        Serial.println(master_RF_channel_num);
        inputMessage4 = master_RF_channel_num;
        writeFile(SPIFFS, "/master_RF_channel_num.txt", inputMessage4.c_str());
        MASTER_channel_RF = master_RF_channel_num;
        Serial.println(" MASTER RF CHANNEL UPDATED " );
        Serial.println(MASTER_channel_RF);
        iport_s();
        hmi.HMT_WriteVPN16(0x0008720E,MASTER_channel_RF);
      break;
      case 0x00087300:   //SEND SELECTED RF CHANNEL TO DEVICES
        Serial.println(" STARTING LOOP TO SHOW SOFTWARE VERSION " );
        for(int i = 0; i <= 17; i++)
        {
          SECONDARY_channel_RF = i;
          iport_r();
          sendCDC_INTERMEDIATOR(12,secondary_RF_channel_num);
        }
        iport_s();
        Serial2.flush();
      break;
      case 0x00089006:   //RESET  RF CHANNEL OF ALL BOARDS AND DEVICES
        //set RF CHANNEL no.  in RF environment
        Serial.println(" SENDING RESET TO ALL DEVICES " );
        Serial.println(secondary_RF_channel_num);
        digitalWrite(BLUE_LED_POS, HIGH);
        hmi.HMT_WirteVPString(0x00003280, &WAIT[0]);
        for(int i = 0; i <= 17; i++)
        {
          SECONDARY_channel_RF = i;
          iport_r();
          Serial2.println(8002);// for master
          Serial2.println(8001);// for secondary
          delay(100);
          Serial.println("SENT RESET TO ALL DEVICES ===========================");
          delay(60);
        }
        hmi.HMT_WirteVPString(0x00003280, &DONE[0]);
        //RESET_DEVICES();
        digitalWrite(BLUE_LED_POS, LOW);
        MASTER_channel_RF = readFile(SPIFFS, "/master_RF_channel_num.txt").toInt();
        iport_s();
        Serial2.flush();
        hmi.HMT_WriteVPN16(0x0008720E,MASTER_channel_RF);
        hmi.HMT_DispPage(68);
      break;
      case 0x0008400A:   //no. of grades to in SELECTED wifi board 
        //Read no. of grades in RF environment
        Serial.println("num_of_groups in the wifi setup board ");
        wifi_setup_num_of_groups = touch_data;
      break;
      case 0x00084008:   //no. of grades to display IN SELECTED WIFI BOARD
        //set  no. of grades in RF environment
        Serial.println("num_of_groups wifi board set update ");
        Serial.println(wifi_setup_num_of_groups);
        hmi.HMT_DispPage(WIFI_GRADE_SET_ID[(wifi_setup_num_of_groups-1)]);// to jump on page in hmi disp wifi GRADE DISP SETTING
        for(int j = 1; j <= num_of_groups; j++)
        {
          int k;
          disp_g_name = G_NAME[j];
          Serial.print("disp_g_name");
          Serial.println(G_NAME[j]);
          disp_g_name_length =  disp_g_name.length();
          disp_g_name.toCharArray(disp_g_name_buff, disp_g_name.length() + 1);
          for (unsigned i = 0; i < (disp_g_name_length); i ++)
          {
            disp_gbuffer[i] = (disp_g_name_buff[i]);
          }
          disp_gbuffer[disp_g_name_length] = 0x00;
          if(j> num_of_groups)
          {
            k = (j + (8-num_of_groups));
            hmi.HMT_WirteVPString(disp_g_name_num[k-1], &disp_gbuffer[0]);
          }
          else
          {
            hmi.HMT_WirteVPString(disp_g_name_num[j-1], &disp_gbuffer[0]);
          }
        }
      break;
      case 0x0008400C:   //SET FONT TYPE FOR RF
        //READ FONT TYPE
        Serial.println("font SET RF ");
        if(touch_data == 0x01)
        {
          Serial.println("font SET 1");
          sendFont_RF(1);
        }
        else if(touch_data == 0x02)
        {
         Serial.println("font SET 2");
         sendFont_RF(2);
        }
        else if(touch_data == 0x03)
        {
          Serial.println("font SET 3");
          sendFont_RF(3);
        }
        else if(touch_data == 0x04)
        {
          Serial.println("SENDING FONT RF");
          hmi.HMT_WirteVPString(0x00001980, &SUCCESSFULL[0]);
          hmi.HMT_DispPage(33);
        }
      break;
      case 0x0008400E:   //SET FONT TYPE FOR WIFI
        //READ FONT TYPE
        Serial.println("font SET WIFI ");
        if(touch_data == 0x01)
        {
          Serial.println("font SET 1");
          wifi_font = 2;
          hmi.HMT_WirteVPString(0x00002100, &SELECTED[0]);
          hmi.HMT_WirteVPString(0x00002180, &BLANK[0]);
          hmi.HMT_WirteVPString(0x00002200, &BLANK[0]);
          //=========== mesh font transmit ==================================//
          Serial.println(" FONT WIFI is = " + Brightness);
          String font_wifi = "FONT," + String(wifi_font) + ","+ String(setup_node_id_mac) + ",";
 
          //mesh.sendBroadcast(font_wifi);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
        else if(touch_data == 0x02)
        {
         Serial.println("font SET 2");
         wifi_font = 1;
         hmi.HMT_WirteVPString(0x00002100, &BLANK[0]);
          hmi.HMT_WirteVPString(0x00002180, &SELECTED[0]);
          hmi.HMT_WirteVPString(0x00002200, &BLANK[0]);
          //=========== mesh font transmit ==================================//
          Serial.println(" FONT WIFI is = " + Brightness);
          String font_wifi = "FONT," + String(wifi_font) + ","+ String(setup_node_id_mac) + ",";
 
          //mesh.sendBroadcast(font_wifi);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
        else if(touch_data == 0x03)
        {
          Serial.println("font SET 3");
          wifi_font = 0;
          hmi.HMT_WirteVPString(0x00002100, &BLANK[0]);
          hmi.HMT_WirteVPString(0x00002180, &BLANK[0]);
          hmi.HMT_WirteVPString(0x00002200, &SELECTED[0]);
          //=========== mesh font transmit ==================================//
          Serial.println(" FONT WIFI is = " + Brightness);
          String font_wifi = "FONT," + String(wifi_font) + ","+ String(setup_node_id_mac) + ",";
 
          //mesh.sendBroadcast(font_wifi);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
        else if(touch_data == 0x04)
        {
          Serial.println("SENDING FONT WIFI");
          
          hmi.HMT_DispPage(40); // to jump on page AUTOBRIGHTNESS
        }
        
      break;
      case 0x00084070:   //SET FONT TYPE FOR WIFI
        //READ FONT TYPE
        Serial.println("font SET WIFI ");
        if(touch_data == 0x01)
        {
          Serial.println("font SET 1");
          wifi_font = 2;
          hmi.HMT_WirteVPString(0x00002100, &SELECTED[0]);
          hmi.HMT_WirteVPString(0x00002180, &BLANK[0]);
          hmi.HMT_WirteVPString(0x00002200, &BLANK[0]);
          //=========== mesh font transmit ==================================//
          Serial.println(" FONT WIFI is = " + Brightness);
          String font_wifi = "MASTERFONT," + String(wifi_font) + ",";
 
          //mesh.sendBroadcast(font_wifi);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
        else if(touch_data == 0x02)
        {
         Serial.println("font SET 2");
         wifi_font = 1;
         hmi.HMT_WirteVPString(0x00002100, &BLANK[0]);
          hmi.HMT_WirteVPString(0x00002180, &SELECTED[0]);
          hmi.HMT_WirteVPString(0x00002200, &BLANK[0]);
          //=========== mesh font transmit ==================================//
          Serial.println(" FONT WIFI is = " + Brightness);
          String font_wifi = "MASTERFONT," + String(wifi_font) + ",";
 
          //mesh.sendBroadcast(font_wifi);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
        else if(touch_data == 0x03)
        {
          Serial.println("font SET 3");
          wifi_font = 0;
          hmi.HMT_WirteVPString(0x00002100, &BLANK[0]);
          hmi.HMT_WirteVPString(0x00002180, &BLANK[0]);
          hmi.HMT_WirteVPString(0x00002200, &SELECTED[0]);
          //=========== mesh font transmit ==================================//
          Serial.println(" FONT WIFI is = " + Brightness);
          String font_wifi = "MASTERFONT," + String(wifi_font) + ",";
 
          //mesh.sendBroadcast(font_wifi);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
        else if(touch_data == 0x04)
        {
          Serial.println("SENDING FONT WIFI");
          
          hmi.HMT_DispPage(76); // to jump on page AUTOBRIGHTNESS
        }
        
      break;
      case 0x00084010:   //scan no. of boards(nodes) available 
        MAXnodesize = readFile(SPIFFS, "/MAXnodesize.txt").toInt();
        //nodesize = mesh.getNodeList().size();
        Serial.print(" MAXnodesize scan = ");
        Serial.println(MAXnodesize);
        //hmi.HMT_WriteVPN16(0x00084012,MAXnodesize);
        hmi.HMT_WriteVPN16(0x00084012,nodesize);
        Serial.println("scanning and showing MAC address of available nodes");
        //00000A00
        //nodeId_array[1]
        
        //for(int j = 0; j < mesh.getNodeList().size()+4; j++)
        /*for(int j = 0; j < MAXnodesize; j++)
        {
          nodeid_mac = String(nodeId_array[j]);
          Serial.print("nodeid_mac");
          Serial.println(nodeid_mac);
          nodeid_mac__length =  nodeid_mac.length();
          nodeid_mac.toCharArray(nodeid_buff, nodeid_mac.length() + 1);
          for (unsigned i = 0; i < (nodeid_mac__length); i ++)
          {
            nodeidbuffer[i] = (nodeid_buff[i]);
          }
          nodeidbuffer[nodeid_mac__length+1] = 0x00;
          hmi.HMT_WirteVPString(nodeid_mac_num[j], &nodeidbuffer[0]);
        }*/
        for(int j = 0; j < 12; j++)
        {
          nodeid_mac = String(live_nodeId_array[j]);
          Serial.print("nodeid_mac");
          Serial.println(nodeid_mac);
          nodeid_mac__length =  nodeid_mac.length();
          nodeid_mac.toCharArray(nodeid_buff, nodeid_mac.length() + 1);
          for (unsigned i = 0; i < (nodeid_mac__length); i ++)
          {
            nodeidbuffer[i] = (nodeid_buff[i]);
          }
          nodeidbuffer[nodeid_mac__length+1] = 0x00;
          hmi.HMT_WirteVPString(nodeid_mac_num[j], &nodeidbuffer[0]);
        }
      break;
      case 0x00084014:   //NODE NO. 1
        //set  no. 1 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[0];
        Serial.println("SETUP NODE 1");
        Serial.println(setup_node_id_mac);
        device_flash = 1;
        flash_timer.restart();
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
      break;
      case 0x00084016:   //NODE NO. 2
        //set  no. 2 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[1];
        Serial.println("SETUP NODE 2");
        Serial.println(setup_node_id_mac);
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
        device_flash = 1;
        flash_timer.restart();
      break;
      case 0x00084018:   //NODE NO. 3
        //set  no. 3 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[2];
        Serial.println("SETUP NODE 3");
        Serial.println(setup_node_id_mac);
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
        device_flash = 1;
        flash_timer.restart();
      break;
      case 0x0008401A:   //NODE NO. 4
        //set  no. 4 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[3];
        Serial.println("SETUP NODE 4");
        Serial.println(setup_node_id_mac);
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
        device_flash = 1;
        flash_timer.restart();
      break;
      case 0x0008401C:   //NODE NO. 5
        //set  no. 5 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[4];
        Serial.println("SETUP NODE 5");
        Serial.println(setup_node_id_mac);
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
        device_flash = 1;
        flash_timer.restart();
      break;
      case 0x0008401E:   //NODE NO. 6
        //set  no. 6 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[5];
        Serial.println("SETUP NODE 6");
        Serial.println(setup_node_id_mac);
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
        device_flash = 1;
        flash_timer.restart();
      break;
      case 0x00084020:   //NODE NO. 7
        //set  no. 7 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[6];
        Serial.println("SETUP NODE 7");
        Serial.println(setup_node_id_mac);
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
        device_flash = 1;
        flash_timer.restart();
      break;
      case 0x00084022:   //NODE NO. 8
        //set  no. 8 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[7];
        Serial.println("SETUP NODE 8");
        Serial.println(setup_node_id_mac);
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
        device_flash = 1;
        flash_timer.restart();
      break;
      case 0x00084024:   //NODE NO. 9
        //set  no. 9 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[8];
        Serial.println("SETUP NODE 9");
        Serial.println(setup_node_id_mac);
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
        device_flash = 1;
        flash_timer.restart();
      break;
      case 0x00084026:   //NODE NO. 10
        //set  no. 10 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[9];
        Serial.println("SETUP NODE 10");
        Serial.println(setup_node_id_mac);
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
        device_flash = 1;
        flash_timer.restart();
      break;
      case 0x00084028:   //NODE NO. 11
        //set  no. 11 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[10];
        Serial.println("SETUP NODE 11");
        Serial.println(setup_node_id_mac);
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
        device_flash = 1;
        flash_timer.restart();
      break;
      case 0x0008402A:   //NODE NO. 12
        //set  no. 12 NODE TO SETUP
        setup_node_id_mac = live_nodeId_array[11];
        Serial.println("SETUP NODE 12");
        Serial.println(setup_node_id_mac);
        hmi.HMT_DispPage(50); // to jump on page in hmi disp
        device_flash = 1;
        flash_timer.restart();
      break;
      case 0x00084036:   //selected device autobrightness on/off
        Serial.println("selected device autobrightness on/off ");
        if(touch_data == 0x00)
        {
          String selected_autobrightness = "AUTOBRIGHTNESS," + String(0) + "," + String(setup_node_id_mac) + ",";
          //mesh.sendBroadcast(selected_autobrightness);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
        else if(touch_data == 0x01)
        {
          String selected_autobrightness = "AUTOBRIGHTNESS," + String(1) + "," + String(setup_node_id_mac) + ",";
          //mesh.sendBroadcast(selected_autobrightness);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
        hmi.HMT_DispPage(41); //wifi master/slave PAGE JUMP
      break;
      case 0x00084072:   //selected device autobrightness on/off
        Serial.println("selected device autobrightness on/off ");
        if(touch_data == 0x00)
        {
          String selected_autobrightness = "AUTOBRIGHTNESS," + String(0) + "," + String(setup_node_id_mac) + ",";
          //mesh.sendBroadcast(selected_autobrightness);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
          hmi.HMT_DispPage(6); //manual control
        }
        else if(touch_data == 0x01)
        {
          String selected_autobrightness = "AUTOBRIGHTNESS," + String(1) + "," + String(setup_node_id_mac) + ",";
          //mesh.sendBroadcast(selected_autobrightness);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
          hmi.HMT_DispPage(42); //manual control
        }
      break;
      case 0x0008403A:   //selected device MASTER/SLAVE(SENSORMODE)
        Serial.println("selected device MASTER/SLAVE SELECTION ");
        /*if(touch_data == 0x00)
        {
          String selected_sensormode = "SENSORMODE," + String(0) + "," + String(setup_node_id_mac) + ",";
          mesh.sendBroadcast(selected_sensormode);
          taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
          hmi.HMT_WirteVPString(0x00002280, &BLANK[0]);
          hmi.HMT_WirteVPString(0x00002300, &SELECTED[0]);
        }
        else if(touch_data == 0x01)
        {
          String selected_sensormode = "SENSORMODE," + String(1) + "," + String(setup_node_id_mac) + ",";
          mesh.sendBroadcast(selected_sensormode);
          taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
          hmi.HMT_WirteVPString(0x00002280, &SELECTED[0]);
          hmi.HMT_WirteVPString(0x00002300, &BLANK[0]);
        }*/
        if(touch_data == 0x00)  //SECONDARY
        {
          String selected_TRANSrfmode = "RFMODE," + String(1) + "," + String(setup_node_id_mac) + ",";
          //mesh.sendBroadcast(selected_TRANSrfmode);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
          String selected_sensormode = "SENSORMODE," + String(0) + "," + String(setup_node_id_mac) + ",";
          //mesh.sendBroadcast(selected_sensormode);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
          hmi.HMT_WirteVPString(0x00002280, &BLANK[0]);
          hmi.HMT_WirteVPString(0x00002300, &SELECTED[0]);
        }
        else if(touch_data == 0x01)//MASTER
        {
          String selected_TRANSrfmode = "RFMODE," + String(3) + "," + String(setup_node_id_mac) + ",";
          //mesh.sendBroadcast(selected_TRANSrfmode);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
          String selected_sensormode = "SENSORMODE," + String(1) + "," + String(setup_node_id_mac) + ",";
          //mesh.sendBroadcast(selected_sensormode);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
          hmi.HMT_WirteVPString(0x00002280, &SELECTED[0]);
          hmi.HMT_WirteVPString(0x00002300, &BLANK[0]);
        }
        hmi.HMT_WirteVPString(0x00002080, &SUCCESSFULL[0]);
      break;
      case 0x0008403E:   //selected device setup complete submit
        hmi.HMT_FillVPSTR(0x00002080,6,&BLANK[0]);
        hmi.HMT_WriteVPN16(0x00084040, 0);
        hmi.HMT_WriteVPN16(0x00084042, 0);
        hmi.HMT_WriteVPN16(0x00084044, 0);
        hmi.HMT_WriteVPN16(0x00084046, 0);
        hmi.HMT_WriteVPN16(0x00084066, 0);
        hmi.HMT_WriteVPN16(0x00084068, 0);
        hmi.HMT_WriteVPN16(0x0008406A, 0);
        hmi.HMT_WriteVPN16(0x0008406C, 0);
        hmi.HMT_WriteVPN16(0x0008400A, 0);
        Serial.println("selected device setup complete submit");
         hmi.HMT_DispPage(5); //wifi setup complete
      break;
      case 0x00084040:   //NODE NO. 1 GRADE SELECTION
        WIFI_SETUP_BOARD_GRADE_SELECT[0] = touch_data;
        Serial.println("SETUP NODE 1  GRADE SELECTION");
        Serial.println(WIFI_SETUP_BOARD_GRADE_SELECT[0]);
        if(WIFI_SETUP_BOARD_GRADE_SELECT[0] > 0x00)
        {
          String selected_digitpos = "DIGITPOSITION," + String(((WIFI_SETUP_BOARD_GRADE_SELECT[0]-1)*3)) + "," + String(setup_node_id_mac) + ",";
         // mesh.sendBroadcast(selected_digitpos);
         // taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
      break;
      case 0x00084042:   //NODE NO. 2 GRADE SELECTION
        WIFI_SETUP_BOARD_GRADE_SELECT[1] = touch_data;
        Serial.println("SETUP NODE 2  GRADE SELECTION");
        Serial.println(WIFI_SETUP_BOARD_GRADE_SELECT[1]);
        if(WIFI_SETUP_BOARD_GRADE_SELECT[0] > 0x00)
        {
          String selected_digitpos = "DIGITPOSITION," + String(((WIFI_SETUP_BOARD_GRADE_SELECT[1]-1)*3)) + "," + String(setup_node_id_mac) + ",";
          //mesh.sendBroadcast(selected_digitpos);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
      break;
      case 0x00084044:   //NODE NO. 3 GRADE SELECTION
        WIFI_SETUP_BOARD_GRADE_SELECT[2] = touch_data;
        Serial.println("SETUP NODE 3  GRADE SELECTION");
        Serial.println(WIFI_SETUP_BOARD_GRADE_SELECT[2]);
        if(WIFI_SETUP_BOARD_GRADE_SELECT[0] > 0x00)
        {
          String selected_digitpos = "DIGITPOSITION," + String(((WIFI_SETUP_BOARD_GRADE_SELECT[2]-1)*3)) + "," + String(setup_node_id_mac) + ",";
          //mesh.sendBroadcast(selected_digitpos);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
      break;
      case 0x00084046:   //NODE NO. 4 GRADE SELECTION
        WIFI_SETUP_BOARD_GRADE_SELECT[3] = touch_data;
        Serial.println("SETUP NODE 4  GRADE SELECTION");
        Serial.println(WIFI_SETUP_BOARD_GRADE_SELECT[3]);
        if(WIFI_SETUP_BOARD_GRADE_SELECT[0] > 0x00)
        {
          String selected_digitpos = "DIGITPOSITION," + String(((WIFI_SETUP_BOARD_GRADE_SELECT[3]-1)*3)) + "," + String(setup_node_id_mac) + ",";
          //mesh.sendBroadcast(selected_digitpos);
          //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
        }
      break;
      case 0x00084048:   //NODE NO. cash allocate submit
        Serial.println("SETUP NODE NO. cash allocate submit");
        hmi.HMT_DispPage(38); //wifi FONT PAGE JUMP
      break;
      case 0x0008404A:   
      break;
      case 0x00084052:   //DEV MAC BLINK SELECTED MAC
        Serial.println("DEV MAC SELECTED BLINK ");
        device_flash =0;  //stop selected device flash
        if(touch_data == 0x00)
        {
          hmi.HMT_DispPage(39);
          Serial.println("SELECTED WRONG BOARD");
        }
        else if(touch_data == 0x01)
        {
          hmi.HMT_DispPage(43);
          Serial.println("SELECTED RIGHT BOARD");
        }
      break;
      case 0x00084054:   //FULL SITE GRADE LEVEL SELECTION
        Serial.println("FULL SITE GRADE LEVEL SELECTION ");
        if(touch_data == 0x00)
        {
          inputMessage4 = "0";
          hmi.HMT_WirteVPString(0x00002000, &SINGLE[0]);
          Serial.println("GRADE LEVEL SINGLE");
          writeFile(SPIFFS, "/group_type.txt", inputMessage4.c_str());
        }
        else if(touch_data == 0x01)
        {
          inputMessage4 = "1";
          hmi.HMT_WirteVPString(0x00002000, &DUAL[0]);
          Serial.println("GRADE LEVEL DUAL");
          writeFile(SPIFFS, "/group_type.txt", inputMessage4.c_str());
        }
      break;
      case 0x00084056:   //SITE SETUP SUBMIT
        //set  no. of grades in  environment AND GROUP TYPE(SINGLE/DUAL)
        Serial.println("num_of_groups set update site setup ");
        inputMessage4 = num_of_groups;
        writeFile(SPIFFS, "/num_of_groups.txt", inputMessage4.c_str());
        hmi.HMT_WriteVPN16(0x00084050,num_of_groups);
        group_type=readFile(SPIFFS, "/group_type.txt").toInt();
        if(num_of_groups <=4 )
        {
          hmi.HMT_DispPage(60); //cash grade name
        }
        else if(num_of_groups == 5 )
        {
          hmi.HMT_DispPage(61); //cash grade name
        }
        else if(num_of_groups == 6 )
        {
          hmi.HMT_DispPage(62); //cash grade name
        }
        else if(num_of_groups ==7 )
        {
          hmi.HMT_DispPage(83); //cash grade name
        }
        else if(num_of_groups >= 8 )
        {
          hmi.HMT_DispPage(84); //cash grade name
        }
      break;
      case 0x00084058:   //SITE CASH GRADE NAME SUBMIT
        Serial.println("SITE CASH GRADE NAME SUBMIT");
        //group_type=readFile(SPIFFS, "/group_type.txt").toInt();
        //if(group_type >= 1)
        //{
        //  hmi.HMT_DispPage(53); //credit grade NAME PAGE JUMP
        //}
        //else
        //{
          hmi.HMT_DispPage(5); //credit grade NAME PAGE JUMP
        //}
      break;
      case 0x0008405A:   //SITE CREDIT GRADE NAME SUBMIT
        Serial.println("SITE CREDIT GRADE NAME SUBMIT");
        hmi.HMT_DispPage(5); //credit grade NAME PAGE JUMP
      break;
      case 0x00086000:   //BRIGHTNESS UPDATE BUTTON
        //Read CDC OFF
        Serial.println("BRIGHTNESS update ");
        hmi.HMT_SendCMD_ReadVPN16(0x00086002);
      break;
      case 0x00089000:   // back button   
      case 0x00089002:   //forward button
        Serial.println("page mooved ");
        // check page change
        hmi.HMT_SendCMD_ReadPageID();
      break;
      case 0x00089004:   //carousal button // clear all string
        Serial.println("carousal mooved ");
        hmi.HMT_FillVPSTR(0x00000080,69,&BLANK[0]);
        hmi.HMT_WriteVPN16(0x00084040, 0);
        hmi.HMT_WriteVPN16(0x00084042, 0);
        hmi.HMT_WriteVPN16(0x00084044, 0);
        hmi.HMT_WriteVPN16(0x00084046, 0);
        hmi.HMT_WriteVPN16(0x00084066, 0);
        hmi.HMT_WriteVPN16(0x00084068, 0);
        hmi.HMT_WriteVPN16(0x0008406A, 0);
        hmi.HMT_WriteVPN16(0x0008406C, 0);
        hmi.HMT_WriteVPN16(0x0008400A, 0);
      break;
      case 0x00085000:   //SIGNUP UPDATE SET PIN
        Serial.println("SIGNUP UPDATE ");
        // check page change
        // COMPARE NEW PIN 1 AND PIN2 // SET 0X600 STATUS OF PIN COMPARISON
        if(create_pin1 == create_pin2)
        {
          writeFile(SPIFFS, "/hmi_pin.txt", create_pin1.c_str());
          Serial.println("PIN SET SUCCESSFULL ");
          hmi.HMT_WirteVPString(0x00000600, &SUCCESSFULL[0]);
          hmi_pin = create_pin1.toInt();
          // update hmi pin register        
          
        }
        else
        {
          hmi.HMT_WirteVPString(0x00000600, &WRONG_PIN[0]);
          Serial.println("PIN NOT MATCHED ");
        }
      break;
      case 0x00085500:   //MASTER ACCESS SHOW OLD PIN
        Serial.println("MASTER ACCESS");
        create_pin1 = readFile(SPIFFS, "/hmi_pin.txt");
        // check page change
        // COMPARE MASTER PIN   // SET 0X900 STATUS OF PIN COMPARISON
        if(master_pin == master_pin_check)
        {
          create_pin1.toCharArray(passbuf, create_pin1.length() + 1);
          for (unsigned i = 0; i < (string__length); i ++)
          {
            passwordbuf[i] = (passbuf[i]);
          }
          passwordbuf[string__length+1] = 0x00;
          hmi.HMT_WirteVPString(0x00000700, &passwordbuf[0]);
          hmi.HMT_WirteVPString(0x00000900, &SUCCESSFULL[0]);
          old_pin = readFile(SPIFFS, "/hmi_pin.txt");
          Serial.println("SHOW PIN MASTER PIN MATCHED ");
        }
        else
        {
          hmi.HMT_WirteVPString(0x00000900, &WRONG_PIN[0]);
          Serial.println("master PIN NOT MATCHED ");
        }
      break;
      case 0x00085600:   //UPDATE NEW PIN
        Serial.println(" UPDATE NEW PIN ");
        create_pin1 = readFile(SPIFFS, "/hmi_pin.txt");
        // check page change
        // COMPARE NEW PIN 1 AND PIN2 // SET 0X600 STATUS OF PIN COMPARISON
        if((updated_pin1 == updated_pin2) && (old_pin == create_pin1))
        {
          writeFile(SPIFFS, "/hmi_pin.txt", updated_pin1.c_str());
          writeFile(SPIFFS, "/create_pin1.txt", updated_pin1.c_str());
          Serial.println("PIN SET SUCCESSFULL ");
          hmi.HMT_WirteVPString(0x00000900, &SUCCESSFULL[0]);
          hmi_pin = updated_pin1.toInt();

        }
        else
        {
          hmi.HMT_WirteVPString(0x00000900, &WRONG_PIN[0]);
          Serial.println("PIN NOT MATCHED ");
        }
      break;
      case 0x00001280:   //RETRIEVE PIN
        Serial.println("show retrieve pin after check  ");
        // check page change
        create_pin1 = readFile(SPIFFS, "/hmi_pin.txt");
        customer_name = readFile(SPIFFS, "/customer_name.txt");
        mobile_number = readFile(SPIFFS, "/mobile_number.txt");
        email = readFile(SPIFFS, "/email.txt");
        company_name = readFile(SPIFFS, "/company_name.txt");

        if(customer_name == retrieve_name)
        {
          Retrieve_count ++;
        }
        if(mobile_number == retrieve_mobile_number)
        {
          Retrieve_count ++;
        }
        if(email == retrieve_email)
        {
          Retrieve_count ++;
        }
        if(company_name == retrieve_company)
        {
          Retrieve_count ++;
        }
        if(Retrieve_count >= 2)   //no. of data match
        {
          Retrieve_count = 0;
          create_pin1.toCharArray(passbuf, create_pin1.length() + 1);
          for (unsigned i = 0; i < (string__length); i ++)
          {
            passwordbuf[i] = (passbuf[i]);
          }
          passwordbuf[string__length+1] = 0x00;
          hmi.HMT_WirteVPString(0x00001200, &passwordbuf[0]);
          Serial.println("SHOW PIN DATA MATCHED ");
        }
        else
        {
           hmi.HMT_WirteVPString(0x00001200, &WRONG_PIN[0]);
          Serial.println("data NOT MATCHED ");
        }
        
        //hmi.HMT_WirteVPString(0x00001200,);
      break;
      case 0x00000080:   //SIGNUP UPDATE
        Serial.println("Read Site_number ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000080); //reading string site number
      break;
      case 0x00000100:   //SIGNUP UPDATE
        Serial.println("Read COMPANY NAME ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000100); //reading string
      break;
      case 0x00000180:   //SIGNUP UPDATE
        Serial.println("Read Site_ADDRESS ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000180); //reading string
      break;
      case 0x00000200:   //SIGNUP UPDATE
        Serial.println("Read CITY ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000200); //reading string
      break;
      case 0x00000280:   //SIGNUP UPDATE
        Serial.println("Read STATE ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000280); //reading string
      break;
      case 0x00000300:   //SIGNUP UPDATE
        Serial.println("Read ZIP CODE ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000300); //reading string
      break;
      case 0x00000380:   //SIGNUP UPDATE
        Serial.println("Read CUSTOMER NAME  ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000380); //reading string
      break;
      case 0x00000400:   //SIGNUP UPDATE
        Serial.println("Read MOBILE  ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000400); //reading string
      break;
      case 0x00000480:   //SIGNUP UPDATE
        Serial.println("Read EMAIL ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000480); //reading string
      break;
      case 0x00000500:   //SIGNUP UPDATE
        Serial.println("Read NEW PIN 1  ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000500); //reading string
      break;
      case 0x00000580:   //SIGNUP UPDATE
        Serial.println("Read NEW PIN 2  ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000580); //reading string
      break;
      case 0x00000680:   //master pin check
        Serial.println("Read master pin  ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000680); //reading string
      break;
      case 0x00000700:   //old pin check
        Serial.println("Read old pin  ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000700); //reading string
      break;
      case 0x00000780:   //updated new pin 1
        Serial.println("Read updated new pin 1  ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000780); //reading string
      break;
      case 0x00000800:   //updated new pin 2
        Serial.println("Read updated new pin 2  ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00000800); //reading string
      break;
      case 0x00001000:   //SIGNUP UPDATE
        Serial.println("Read RETRIEVE NAME ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00001000); //reading string
      break;
      case 0x00001080:   //SIGNUP UPDATE
        Serial.println("Read RETRIEVE MOBILE NUM  ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00001080); //reading string
      break;
      case 0x00001100:   //SIGNUP UPDATE
        Serial.println("Read RETRIEVE EMAIL  ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00001100); //reading string
      break;
      case 0x00001180:   //SIGNUP UPDATE
        Serial.println("Read RETRIEVE COMPANY NAME  ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00001180); //reading string
      break;
      case 0x00001400:   //LOGIN PAGE PIN INPUT CHECK
        old_pin = readFile(SPIFFS, "/hmi_pin.txt");
        Serial.println("CHECK INPUT PIN");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00001400); //reading string
      break;
      case 0x00001700:   //setup wifi board name
        Serial.println("Read wifi mac board name ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00001700); //reading string
      break;
      case 0x00001780:   //setup wifi SSID name
        Serial.println("Read  wifi mac SSID name ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00001780); //reading string
      break;
      case 0x00001800:   //setup wifi PASSWORD
        Serial.println("Read wifi PASSWORD ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00001800); //reading string
      break;
      case 0x00001880:  //setup wifi PORT NUM
        Serial.println("Read wifi PORT NUM ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00001880); //reading string
      break;
      case 0x00001900:   //setup wifi CHANNEL NUM
        Serial.println("Read wifi CHANNEL NUM ");
        // check page change
        hmi.HMT_SendCMD_ReadVPString(0x00001900); //reading string
      break;
      case 0x00001A00:   //GRADE1 CASH NAME
        Serial.println("GRADE 1 CASH NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00001A00); //reading string
      break;
      case 0x00001A80:   //GRADE2 CASH NAME
        Serial.println("GRADE 2 CASH NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00001A80); //reading string
      break;
      case 0x00001B00:   //GRADE3 CASH NAME
        Serial.println("GRADE 3 CASH NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00001B00); //reading string
      break;
      case 0x00001B80:   //GRADE4 CASH NAME
        Serial.println("GRADE 4 CASH NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00001B80); //reading string
      break;
      case 0x00001C00:   //GRADE5 CASH NAME
        Serial.println("GRADE 5 CASH NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00001C00); //reading string
      break;
      case 0x00001C80:   //GRADE6 CASH NAME
        Serial.println("GRADE 6 CASH NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00001C80); //reading string
      break;
      case 0x00001D00:   //GRADE 7 CASH NAME
        Serial.println("GRADE 7 CASH NAME ");
        hmi.HMT_SendCMD_ReadVPString(0x00001D00); //reading string
      break;
      case 0x00001D80:   //GRADE 8 CASH NAME
        Serial.println("GRADE 8 CASH NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00001D80); //reading string
      break;


      case 0x00001E00:   //GRADE1 CREDIT NAME
        Serial.println("GRADE 1 CREDIT NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00001E00); //reading string
      break;
      case 0x00001E80:   //GRADE2 CREDIT NAME
        Serial.println("GRADE 2 CREDIT NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00001E80); //reading string
      break;
      case 0x00001F00:   //GRADE3 CREDIT NAME
        Serial.println("GRADE 3 CREDIT NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00001F00); //reading string
      break;
      case 0x00001F80:   //GRADE4 CREDIT NAME
        Serial.println("GRADE 4 CREDIT NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00001F80); //reading string
      break;
      case 0x00003000:   //GRADE5 CREDIT NAME
        Serial.println("GRADE 5 CREDIT NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00003000); //reading string
      break;
      case 0x00003080:   //GRADE6 CREDIT NAME
        Serial.println("GRADE 6 CREDIT NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00003080); //reading string
      break;
      case 0x00003100:   //GRADE7 CREDIT NAME
        Serial.println("GRADE 7 CREDIT NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00003100); //reading string
      break;
      case 0x00003180:   //GRADE8 CREDIT NAME
        Serial.println("GRADE 8 CREDIT NAME  ");
        hmi.HMT_SendCMD_ReadVPString(0x00003180); //reading string
      break;
      default:
      Serial.println("NO address = ");
      Serial.println(address, HEX);
      break;
  }
}

//============================== hmi_serial_recieve =============================//
void hmi_serial_recieve()
{ 
  
  if(hmi_data_recieve[0] == 0XAA) //data recive started
  {
    //Serial.println("start byte");
    switch (hmi_data_recieve[1]) 
    {
      case 0X3E:  //N16_READ
        //Serial.println("Choice is 1");
        //hmi_address = hmi.__find_address(&hmi_data_recieve[0]); 
        hmi_read_data_check(0x00086002);
        Serial.println("BRIGHTNESS READ");
        break;
      case 0X83:  //HMT_Successive_ReadNumVp
        //Serial.println("Choice is 2");
        hmi_address = hmi.__find_address(&hmi_data_recieve[0]);
        data_length = hmi_data_recieve[6];
        data_st_byte = 7;//HMT_Successive_ReadNumVp
        hmi_read_data_check(hmi_address);
        Serial.println("SUCCESIVE READ");
        break;
      case 0X77:  //TOUCH RESPONSE
        //Serial.println("Choice is 3");
        hmi_address = hmi.__find_address(&hmi_data_recieve[0]);
        data_num = 1;
        data_st_byte = 6;//TOUCH RESPONSE
        touch_data = hmi.__find_data(&hmi_data_recieve[0],data_st_byte, data_num);
        Serial.println("touch_data = ");
        Serial.println(touch_data, HEX); 
        hmi_address_check(hmi_address);
        break;
      case 0X32:  //PAGE ID RESPONSE
        data_num = 1;
        data_st_byte = 2;//PAGE ID RESPONSE
        page_id = hmi.__find_data(&hmi_data_recieve[0],data_st_byte, data_num);
        Serial.print("page_id data = ");
        Serial.println(page_id);
        break;
      case 0X43:  //STRING READ RESPONSE
        byte incomingByte;
        Serial.println("STRING DATA =");
        //String CardID = "";
        for (unsigned i = 2; i < 50; i++)
        {
          if(hmi_data_recieve[i] != 0x00)
          {
            //Serial.println(hmi_data_recieve[i],HEX);
            incomingByte = hmi_data_recieve[i];
            inputString += "0123456789ABCDEF"[incomingByte / 16];
            inputString += "0123456789ABCDEF"[incomingByte % 16];
          }
          else
          {
            i = 50;  //overflow for loop
          }
        }
        //Serial.print("inputString =");
        //Serial.println(inputString);
        string__length =  inputString.length();
        for (unsigned i = 0; i < string__length; i += 2)
        {
          //Serial.print(HexByte(&inputString[i]));
          inputString_ascii += HexByte(&inputString[i]);
        }  
        
        //Serial.print("inputString = ");
        if(hmi_address == 0x00000080)
        {
          site_serial_number = inputString_ascii;  //update string
          writeFile(SPIFFS, "/site_serial_number.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000100)
        {
          company_name = inputString_ascii;  //update string
          writeFile(SPIFFS, "/company_name.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000180)
        {
          site_address = inputString_ascii;  //update string
          writeFile(SPIFFS, "/site_address.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000200)
        {
          city = inputString_ascii;  //update string
          writeFile(SPIFFS, "/city.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000280)
        {
          state = inputString_ascii;  //update string
          writeFile(SPIFFS, "/state.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000300)
        {
          zip_code = inputString_ascii;  //update string
          writeFile(SPIFFS, "/zip_code.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000380)
        {
          customer_name = inputString_ascii;  //update string
          writeFile(SPIFFS, "/customer_name.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000400)
        {
          mobile_number = inputString_ascii;  //update string
          writeFile(SPIFFS, "/mobile_number.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000480)
        {
          email = inputString_ascii;  //update string
          writeFile(SPIFFS, "/email.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000500)
        {
          create_pin1 = inputString_ascii;  //update string
          writeFile(SPIFFS, "/create_pin1.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000580)
        {
          create_pin2 = inputString_ascii;  //update string
          writeFile(SPIFFS, "/create_pin2.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000680)
        {
          master_pin_check = inputString_ascii;  //update string
          writeFile(SPIFFS, "/master_pin_check.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000700)
        {
          old_pin = inputString_ascii;  //update string
          writeFile(SPIFFS, "/old_pin.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000780)
        {
          updated_pin1 = inputString_ascii;  //update string
          writeFile(SPIFFS, "/updated_pin1.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00000800)
        {
          updated_pin2 = inputString_ascii;  //update string
          writeFile(SPIFFS, "/updated_pin2.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00001000)
        {
          retrieve_name = inputString_ascii;  //update string
          writeFile(SPIFFS, "/retrieve_name.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00001080)
        {
          retrieve_mobile_number = inputString_ascii;  //update string
          writeFile(SPIFFS, "/retrieve_mobile_number.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00001100)
        {
          retrieve_email = inputString_ascii;  //update string
          writeFile(SPIFFS, "/retrieve_email.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00001180)
        {
          retrieve_company = inputString_ascii;  //update string
          writeFile(SPIFFS, "/retrieve_company.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00001400)
        {
          old_pin = readFile(SPIFFS, "/hmi_pin.txt");
          login_pin = inputString_ascii;  //update string LOGIN
          Serial.println(" login PIN recieved ");
          Serial.println(login_pin);
          if((old_pin == login_pin))
          {
            login_pin = "";
            Serial.println("PIN dial SUCCESSFULL ");
            hmi.HMT_WirteVPString(0x00001480, &SUCCESSFULL[0]);
            hmi_pin = updated_pin1.toInt();
            hmi.HMT_DispPage(4);
          }
          else
          {
            Serial.println("PIN dial wrong ");
            hmi.HMT_WirteVPString(0x00001480, &WRONG_PIN[0]);
          }
          
        }
        else if(hmi_address == 0x00001700)
        {
          wifi_setup_board_name = inputString_ascii;  //update string
          Serial.println(wifi_setup_board_name);
        }
        else if(hmi_address == 0x00001780)
        {
          wifi_setup_ssid = inputString_ascii;  //update string
          Serial.println(wifi_setup_ssid);
        }
        else if(hmi_address == 0x00001800)
        {
          wifi_setup_password = inputString_ascii;  //update string
          Serial.println(wifi_setup_password);
        }
        else if(hmi_address == 0x00001880)
        {
          wifi_setup_port_number = inputString_ascii;  //update string
          Serial.println(wifi_setup_port_number);
        }
        else if(hmi_address == 0x00001900)
        {
          wifi_setup_channel_number = inputString_ascii;  //update string
          Serial.println(wifi_setup_channel_number);
        }
        else if(hmi_address == 0x00001A00)
        {
          G_NAME[1] = inputString_ascii;  //update string
          if(group_type >= 1)
          {
            G_NAME[1] = (inputString_ascii + const_cash);
            if(num_of_groups == 4)
            {
              G_NAME[num_of_groups+1] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G5_NAME.txt", G_NAME[num_of_groups+1].c_str());
            }
            else if(num_of_groups == 5)
            {
              G_NAME[num_of_groups+1] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G6_NAME.txt", G_NAME[num_of_groups+1].c_str());
            }
            else if(num_of_groups == 6)
            {
              G_NAME[num_of_groups+1] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G7_NAME.txt", G_NAME[num_of_groups+1].c_str());
            }
            else if(num_of_groups == 7)
            {
              G_NAME[num_of_groups+1] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G8_NAME.txt", G_NAME[num_of_groups+1].c_str());
            }
            else if(num_of_groups == 8)
            {
              G_NAME[num_of_groups+1] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G9_NAME.txt", G_NAME[num_of_groups+1].c_str());
            }
          }
          writeFile(SPIFFS, "/G1_NAME.txt", G_NAME[1].c_str());
        }
        else if(hmi_address == 0x00001A80)
        {
          G_NAME[2] = inputString_ascii;  //update string
          if(group_type >= 1)
          {
            G_NAME[2] = (inputString_ascii + const_cash);
            if(num_of_groups == 4)
            {
              G_NAME[num_of_groups+2] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G6_NAME.txt", G_NAME[num_of_groups+2].c_str());
            }
            else if(num_of_groups == 5)
            {
              G_NAME[num_of_groups+2] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G7_NAME.txt", G_NAME[num_of_groups+2].c_str());
            }
            else if(num_of_groups == 6)
            {
              G_NAME[num_of_groups+2] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G8_NAME.txt", G_NAME[num_of_groups+2].c_str());
            }
            else if(num_of_groups == 7)
            {
              G_NAME[num_of_groups+2] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G9_NAME.txt", G_NAME[num_of_groups+2].c_str());
            }
            else if(num_of_groups == 8)
            {
              G_NAME[num_of_groups+2] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G10_NAME.txt", G_NAME[num_of_groups+2].c_str());
            }
          }
          writeFile(SPIFFS, "/G2_NAME.txt", G_NAME[2].c_str());
        }
        else if(hmi_address == 0x00001B00)
        {
          G_NAME[3] = inputString_ascii;  //update string
          if(group_type >= 1)
          {
            G_NAME[3] = (inputString_ascii + const_cash);
            if(num_of_groups == 4)
            {
              G_NAME[num_of_groups+3] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G7_NAME.txt", G_NAME[num_of_groups+3].c_str());
            }
            else if(num_of_groups == 5)
            {
              G_NAME[num_of_groups+3] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G8_NAME.txt", G_NAME[num_of_groups+3].c_str());
            }
            else if(num_of_groups == 6)
            {
              G_NAME[num_of_groups+3] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G9_NAME.txt", G_NAME[num_of_groups+3].c_str());
            }
            else if(num_of_groups == 7)
            {
              G_NAME[num_of_groups+3] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G10_NAME.txt", G_NAME[num_of_groups+3].c_str());
            }
            else if(num_of_groups == 8)
            {
              G_NAME[num_of_groups+3] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G11_NAME.txt", G_NAME[num_of_groups+3].c_str());
            }
          }
          writeFile(SPIFFS, "/G3_NAME.txt", G_NAME[3].c_str());
        }
        else if(hmi_address == 0x00001B80)
        {
          G_NAME[4] = inputString_ascii;  //update string
          if(group_type >= 1)
          {
            G_NAME[4] = (inputString_ascii + const_cash);
            if(num_of_groups == 4)
            {
              G_NAME[num_of_groups+4] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G8_NAME.txt", G_NAME[num_of_groups+4].c_str());
            }
            else if(num_of_groups == 5)
            {
              G_NAME[num_of_groups+4] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G9_NAME.txt", G_NAME[num_of_groups+4].c_str());
            }
            else if(num_of_groups == 6)
            {
              G_NAME[num_of_groups+4] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G10_NAME.txt", G_NAME[num_of_groups+4].c_str());
            }
            else if(num_of_groups == 7)
            {
              G_NAME[num_of_groups+4] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G11_NAME.txt", G_NAME[num_of_groups+4].c_str());
            }
            else if(num_of_groups == 8)
            {
              G_NAME[num_of_groups+4] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G12_NAME.txt", G_NAME[num_of_groups+4].c_str());
            }
          }
          writeFile(SPIFFS, "/G4_NAME.txt", G_NAME[4].c_str());
        }
        else if(hmi_address == 0x00001C00)
        {
          G_NAME[5] = inputString_ascii;  //update string
          if(group_type >= 1)
          {
            G_NAME[5] = (inputString_ascii + const_cash);
            if(num_of_groups == 4)
            {
              G_NAME[num_of_groups+5] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G9_NAME.txt", G_NAME[num_of_groups+5].c_str());
            }
            else if(num_of_groups == 5)
            {
              G_NAME[num_of_groups+5] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G10_NAME.txt", G_NAME[num_of_groups+5].c_str());
            }
            else if(num_of_groups == 6)
            {
              G_NAME[num_of_groups+5] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G11_NAME.txt", G_NAME[num_of_groups+5].c_str());
            }
            else if(num_of_groups == 7)
            {
              G_NAME[num_of_groups+5] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G12_NAME.txt", G_NAME[num_of_groups+5].c_str());
            }
            else if(num_of_groups == 8)
            {
              G_NAME[num_of_groups+5] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G13_NAME.txt", G_NAME[num_of_groups+5].c_str());
            }
          }
          writeFile(SPIFFS, "/G5_NAME.txt", G_NAME[5].c_str());
        }
        else if(hmi_address == 0x00001C80)
        {
          G_NAME[6] = inputString_ascii;  //update string
          if(group_type >= 1)
          {
            G_NAME[6] = (inputString_ascii + const_cash);
            if(num_of_groups == 4)
            {
              G_NAME[num_of_groups+6] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G10_NAME.txt", G_NAME[num_of_groups+6].c_str());
            }
            else if(num_of_groups == 5)
            {
              G_NAME[num_of_groups+6] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G11_NAME.txt", G_NAME[num_of_groups+6].c_str());
            }
            else if(num_of_groups == 6)
            {
              G_NAME[num_of_groups+6] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G12_NAME.txt", G_NAME[num_of_groups+6].c_str());
            }
            else if(num_of_groups == 7)
            {
              G_NAME[num_of_groups+6] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G13_NAME.txt", G_NAME[num_of_groups+6].c_str());
            }
            else if(num_of_groups == 8)
            {
              G_NAME[num_of_groups+6] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G14_NAME.txt", G_NAME[num_of_groups+6].c_str());
            }
          }
          writeFile(SPIFFS, "/G6_NAME.txt", G_NAME[6].c_str());
        }
        else if(hmi_address == 0x00001D00)
        {
          G_NAME[7] = inputString_ascii;  //update string
          if(group_type >= 1)
          {
            G_NAME[7] = (inputString_ascii + const_cash);
            if(num_of_groups == 4)
            {
              G_NAME[num_of_groups+7] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G11_NAME.txt", G_NAME[num_of_groups+7].c_str());
            }
            else if(num_of_groups == 5)
            {
              G_NAME[num_of_groups+7] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G12_NAME.txt", G_NAME[num_of_groups+7].c_str());
            }
            else if(num_of_groups == 6)
            {
              G_NAME[num_of_groups+7] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G13_NAME.txt", G_NAME[num_of_groups+7].c_str());
            }
            else if(num_of_groups == 7)
            {
              G_NAME[num_of_groups+7] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G14_NAME.txt", G_NAME[num_of_groups+7].c_str());
            }
            else if(num_of_groups == 8)
            {
              G_NAME[num_of_groups+7] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G15_NAME.txt", G_NAME[num_of_groups+7].c_str());
            }
          }
          writeFile(SPIFFS, "/G7_NAME.txt", G_NAME[7].c_str());
        }
        else if(hmi_address == 0x00001D80)
        {
          G_NAME[8] = inputString_ascii;  //update string
          if(group_type >= 1)
          {
            G_NAME[8] = (inputString_ascii + const_cash);
            if(num_of_groups == 4)
            {
              G_NAME[num_of_groups+8] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G12_NAME.txt", G_NAME[num_of_groups+8].c_str());
            }
            else if(num_of_groups == 5)
            {
              G_NAME[num_of_groups+8] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G13_NAME.txt", G_NAME[num_of_groups+8].c_str());
            }
            else if(num_of_groups == 6)
            {
              G_NAME[num_of_groups+8] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G14_NAME.txt", G_NAME[num_of_groups+8].c_str());
            }
            else if(num_of_groups == 7)
            {
              G_NAME[num_of_groups+8] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G15_NAME.txt", G_NAME[num_of_groups+8].c_str());
            }
            else if(num_of_groups == 8)
            {
              G_NAME[num_of_groups+8] = (inputString_ascii + const_credit);
              writeFile(SPIFFS, "/G16_NAME.txt", G_NAME[num_of_groups+8].c_str());
            }
          }
          writeFile(SPIFFS, "/G8_NAME.txt", G_NAME[8].c_str());
        }
        /*
        else if(hmi_address == 0x00001D00)
        {
          G7_NAME = inputString_ascii;  //update string
          writeFile(SPIFFS, "/G7_NAME.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00001D80)
        {
          G8_NAME = inputString_ascii;  //update string
          writeFile(SPIFFS, "/G8_NAME.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00001E00)
        {
          G9_NAME = inputString_ascii;  //update string
          writeFile(SPIFFS, "/G9_NAME.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00001E80)
        {
          G10_NAME = inputString_ascii;  //update string
          writeFile(SPIFFS, "/G10_NAME.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00001F00)
        {
          G11_NAME = inputString_ascii;  //update string
          writeFile(SPIFFS, "/G11_NAME.txt", inputString_ascii.c_str());
        }
        else if(hmi_address == 0x00001F80)
        {
          G12_NAME = inputString_ascii;  //update string
          writeFile(SPIFFS, "/G12_NAME.txt", inputString_ascii.c_str());
        }*/
        
        inputString = "";// Done with inputString. Reset for next message.
        inputString_ascii=""; //Reset for next message.
        break;
      default:
        Serial.println("Choice cmd =");
        Serial.println(hmi_data_recieve[1],HEX);
        break;
    }
  }
}
//============================== HMI INTERFACE =============================//
void HMI_INTERFACE()
{
  if(Serial1.available() > 0)
  {
    byte cmd[56] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    Serial1.readBytesUntil(0x3C,cmd, 56);
    //Serial1.readBytes(cmd, 12);
    //Serial.println("Serial1.available");
    //byte checksum = (0x100 - ((cmd[0] + cmd[1] + cmd[2] + cmd[3] + cmd[4] + cmd[5] + cmd[6] + cmd[7] + cmd[8]) % 0x100));
    //delay(5);
    for (int i = 0; i < 56; i++)
    {
      //if(cmd[i] > 0)
      {
        hmi_data_recieve[i] = cmd[i];
        //Serial.print("0x");
        //Serial.print(cmd[i], HEX);
        //Serial.print(" ");
      }
    }
    //hmi_serial_recieve();
    hmi_serial_recieved = true;
    //Serial.print("HMI_SERIAL");
  }
  
}
void Gillbarco_data_update()
{
  if(giilbarco_data_rec == true)  // new value recieved gillbarco
      {
        giilbarco_data_rec = false;
          if(num_of_groups == 4)
          {
            for (int x = 0; x < 24; x++) {
              Serial.print(GILL_VER_digitval[x]);
              data_value[x] = GILL_VER_digitval[x];
            }
            
          }
        if(POS_setup_enable == 3) // Gillbarco selection
        {
          if(num_of_groups == 5)
          {
            for (int x = 0; x < 12; x++) {
              Serial.println(GILL_VER_digitval[x]);
              data_value[x] = GILL_VER_digitval[x];
            }
            for (int y = 15; y < 27; y++) {
              Serial.println(GILL_VER_digitval[y-3]);
              data_value[y] = GILL_VER_digitval[y-3];
            }
          }
          else if(num_of_groups == 6)
          {
            for (int x = 0; x < 12; x++) {
              Serial.println(GILL_VER_digitval[x]);
              data_value[x] = GILL_VER_digitval[x];
            }
            for (int y = 18; y < 30; y++) {
              Serial.println(GILL_VER_digitval[y-6]);
              data_value[y] = GILL_VER_digitval[y-6];
            }
          }
          else if(num_of_groups == 7)
          {
            for (int x = 0; x < 12; x++) {
              Serial.println(GILL_VER_digitval[x]);
              data_value[x] = GILL_VER_digitval[x];
            }
            for (int y = 21; y < 33; y++) {
              Serial.println(GILL_VER_digitval[y-9]);
              data_value[y] = GILL_VER_digitval[y-9];
            }
          }
          else if(num_of_groups == 8)
          {
            for (int x = 0; x < 12; x++) {
              Serial.println(GILL_VER_digitval[x]);
              data_value[x] = GILL_VER_digitval[x];
            }
            for (int y = 24; y < 36; y++) {
              Serial.println(GILL_VER_digitval[y-12]);
              data_value[y] = GILL_VER_digitval[y-12];
            }
          }
        }
        else if (POS_setup_enable == 2) // Verifone setup
        {
          if(num_of_groups == 5)
          {
            for (int x = 0; x < 30; x++) {
              Serial.print(GILL_VER_digitval[x]);
              data_value[x] = GILL_VER_digitval[x];
            }
          }
          else if(num_of_groups == 6)
          {
            for (int x = 0; x < 15; x++) {
              Serial.println(GILL_VER_digitval[x]);
              data_value[x] = GILL_VER_digitval[x];
            }
            for (int y = 18; y < 33; y++) {
              Serial.println(GILL_VER_digitval[y-3]);
              data_value[y] = GILL_VER_digitval[y-3];
            }
          }
          else if(num_of_groups == 7)
          {
            for (int x = 0; x < 15; x++) {
              Serial.println(GILL_VER_digitval[x]);
              data_value[x] = GILL_VER_digitval[x];
            }
            for (int y = 21; y < 36; y++) {
              Serial.println(GILL_VER_digitval[y-6]);
              data_value[y] = GILL_VER_digitval[y-6];
            }
          }
          else if(num_of_groups == 8)
          {
            for (int x = 0; x < 15; x++) {
              Serial.println(GILL_VER_digitval[x]);
              data_value[x] = GILL_VER_digitval[x];
            }
            for (int y = 24; y < 39; y++) {
              Serial.println(GILL_VER_digitval[y-9]);
              data_value[y] = GILL_VER_digitval[y-9];
            }
          }
        }
        
        //--------------- update recieved values----------------------//
        hmi_cash_price = true;  //cash price recieved
        intermediator_price_update = true;  //data data_transmit_rf 
        hmi_credit_price = true;  //credit recieved
        intermediator_price_update = true;  //data data_transmit_rf 
          price_grade_1_update = true;
          price_grade_2_update = true;
          price_grade_3_update = true;
          price_grade_4_update = true;
          price_grade_5_update = true;
          price_grade_6_update = true;
          price_grade_7_update = true;
          price_grade_8_update = true;
          price_grade_9_update = true;
          price_grade_10_update = true;
          price_grade_11_update = true;
          price_grade_12_update = true;
          price_grade_13_update = true;
          price_grade_14_update = true;
          price_grade_15_update = true;
          price_grade_16_update = true;
        
        hmi_data_value_update();//digit update
        
        hmi_price_value_update(); //display update
        hmi.HMT_Successive_WriteNumVp(0x00080002,24,&hmi_price_digit_g[0]);
        hmi.HMT_Successive_WriteNumVp(0x00080034,24,&hmi_price_digit_g[48]);
      }
}
//==============================  Gillbarco INTERFACE =============================//
void Gillbarco() 
{
  //-------------------------------- Gilbarco read and gather ------
  if (GILL_VER_SERIAL.available() > 0) 
  {
    //Serial.println("gillbarco data recieved");
    timerupdate.restart();

    byte data = GILL_VER_SERIAL.read();
    Serial.println(data, DEC);

    delay(5);

    if (data == START) {
      digitalWrite(WHITE_LED_POS, HIGH);
      newPrice = true;
      digit = 0;
      for (int x = 0; x < 5; x++)
        price[x] = 0;
      category = 0;
      inProcess = false;
      readyToSend = false;
    } else if (newPrice && (data == PRICE)) {
      inProcess = true;
    } else if (inProcess && ((data >> 4) == DATA)) {
      if (category == 0) {
        category = (data & 15);
      } else {
        price[digit] = (data & 15);
        digit++;
      }
    } else if (data == STOP) {
      digitalWrite(WHITE_LED_POS, LOW);
      for (int x = 0; x < 5; x++)
        readyToSend = true;
    } else if ((data >> 4) == CHK) {
      GILL_VER_SERIAL.write(ACK);
      Serial.println("ACK");
    } else {
      Serial.println("Bad Data!!!");
      inProcess = false;
      newPrice = false;
      digit = 0;
      category = 0;
      readyToSend = false;
    }
    if (readyToSend) {
      for (int x = 0; x < 3; x++) {
        GILL_VER_digitval[(((category - 1) * 3) + x)] = price[x];
        Serial.println("gathering");
        delay(1);
      }
      for (int x = 0; x < 24; x++) {
        if (GILL_VER_digitval[x] != GILL_VER_digitvalold[x]) {
          GILL_VER_digitvalold[x] = GILL_VER_digitval[x];
          giilbarco_data_rec = true;
          gill_update.restart();
        }
      }
       //Serial.print("GILL_VER_digitval[x]");
    }
  }
}

//----------------------------------MEM----------------------------------
void mem() {
  Serial.println("");
  digitalWrite(BLUE_LED_POS, HIGH);

  iport_s();
  Serial.println("MEM");
  delay(100);

  char buffer1[40];
  for (int x = 0; x < 48; x++) {
    if (digitval[x] != digitvalold[x]) {
      delay(10);
      digitvalold[x] = digitval[x];
      Serial.print(digitval[x]);
      Serial.print(",");
      itoa(((x) << 8) | ((digitval[x] << 3) | 5), buffer1, 10);
      SUMout += (digitval[x]);
      Serial2.println(buffer1);
      delay(40);
    } else {
      delay(5);
      Serial.print("same,");
    }
    delay(100);

    Serial2.println(9011);
    delay(40);
    Serial2.println(SUMout);

    delay(100);
    Serial.println("");
    digitalWrite(BLUE_LED_POS, LOW);
    Serial2.flush();
    SUMout = 0;
  }
  data_update();  //to update screen price grade data from veriphone
}
//----------------------------------ECHO----------------------------------

void resend() {
  digitalWrite(BLUE_LED_POS, HIGH);
  iport_s();
  Serial.println("resent");
  delay(100);

  char buffer1[40];

  for (int digit = 0; digit < 36; digit++) {
    delay(10);
    itoa(((digit) << 8) | ((digitval[digit] << 3) | 5), buffer1, 10);
    Serial2.println(buffer1);
    SUMout += digitval[digit];
    
  }
  delay(200);
    digitalWrite(8, 0); // enter AT command mode
    delay(80);
    Serial2.print(F("AT+SLEEP"));
    String input = Serial2.readString();
    Serial.println(input);
    delay(80);
    digitalWrite(8, 1); // enter transparent mode
    delay(40);

  delay(100);

    Serial2.println(9011);
    delay(40);
    Serial2.println(SUMout);

    delay(100);

  digitalWrite(BLUE_LED_POS, LOW);
  Serial2.flush();
  SUMout = 0;
  data_update();
}
void node_change_update()
{
  //nodes = mesh.getNodeList();
  Serial.printf("Num nodes: %d\n", nodes.size());
  Serial.printf("Connection list:");
  SimpleList<uint32_t>::iterator node = nodes.begin();
  connected_node_size = mesh.getNodeList().size();

  uint32_t mat[nodes.size()][2],mat_nod[10]={0,0,0,0,0,0,0,0,0,0};
  int count_node = 0;
  while (node != nodes.end()) 
    {
      
      Serial.println("new node recieved");
      Serial.printf(" %u", *node);
      mat_nod[count_node] = *node;
      count_node++;
      node++;
    }

  for(int i=0;i<(nodes.size());i++)
  {
    Serial.println("mat_nod[i] = ");
    Serial.println(mat_nod[i]);
    Serial.println();
    for(int j=0;j<(20);j++)
    {
      Serial.println(nodeId_array[j]);
      
      if((mat_nod[i]) == (nodeId_array[j]))
      {
       //i = i+1;  //for loop break
       j = 500;  //for loop break
       Serial.println("RECIEVED MAC ALREADY WRITTEN");
      }
      else if(((nodeId_array[j]) != (mat_nod[i])) && (nodeId_array[j] <1000))
      {
        nodeId_array[j] = mat_nod[i];// save the node
        j = 500;  //for loop break
        MAXnodesize++;
        String inputMessage5;
        inputMessage5 = MAXnodesize;
        
        writeFile(SPIFFS, "/MAXnodesize.txt", inputMessage5.c_str());
        Serial.println();
        Serial.println("MAXnodesize in  changedConnectionCallback = ");
        Serial.print(MAXnodesize);
      }
      
    }
    if(old_node_size < connected_node_size)
    {
      for(int k=0;k<(20);k++)// live nodes save
    {
      if((live_nodeId_array[k] != mat_nod[i]) && (live_nodeId_array[k] <1000))
      {
        live_nodeId_array[k] = mat_nod[i];// save the node
        k = 500;  //for loop break
        LIVEnodesize =  mesh.getNodeList().size();
        Serial.println("node change LIVE NODE ADDED");
        Serial.print(live_nodeId_array[k]);
      }
      else if((live_nodeId_array[k] == mat_nod[i]))
      {
       k = 500;  //for loop break
       Serial.println("RECIEVED LIVE ALREADY ");
      }
      if(i == (nodes.size() - 1)) //remove extra
      {
        for(int l=nodes.size();l<(20);l++)// live nodes save
        {
          live_nodeId_array[l] = 0;
        }
      }
    }
    }
    else
    {
      live_nodeId_array[i] = mat_nod[i];
      Serial.println("LIVE NODE LOST UPDATE");
      Serial.print(live_nodeId_array[i]);
      if(i == (nodes.size() - 1))
      {
        for(int l=nodes.size();l<(20);l++)// live nodes save
        {
          live_nodeId_array[l] = 0;
        }
      }
    }
    
  }
    /*
    else
    {
      for(int i=0;i<(nodes.size()+1);i++){
        Serial.print("mat_nod[i]");
        Serial.print(mat_nod[i]);
        if(nodeId_array[i] != mat_nod[i])
          {
            nodeId_array[i] = mat_nod[i];// save the node
            //i = 500;  //for loop break
          }
      }
    }*/
    
  
}
//========================================== setup ===============================//
void setup() 
{
  Serial.begin(115200);
  Serial.setTimeout(40);
  Serial2.begin(9600, SERIAL_8N1, RXD2, TXD2);  // Serial for RF
  Serial2.setTimeout(40);
  Serial1.begin(9600, SERIAL_8N1, RXD3, TXD3); //Rx , Tx Serial input FOR HMI
  if(POS_setup_enable == 2)
  {
    GILL_VER_SERIAL.begin(9600); //Rx , Tx Serial input FOR FOR LAN //GILLBARCO//VERIFONE
    GILL_VER_SERIAL.setTimeout(50);
  }
  else if(POS_setup_enable == 3)
  {
    GILL_VER_SERIAL.begin(1200); //Rx , Tx Serial input FOR FOR LAN //GILLBARCO//VERIFONE
  }
  
  //GILL_VER_SERIAL.begin(9600);
  #ifdef ESP32
    if(!SPIFFS.begin(true)){
      Serial.println("An Error has occurred while mounting SPIFFS");
      return;
    }
  #else
    if(!SPIFFS.begin()){
      Serial.println("An Error has occurred while mounting SPIFFS");
      return;
    }
  #endif
  Serial.println("Serial Txd is on pin: "+String(TX));
  Serial.println("Serial Rxd is on pin: "+String(RX));

 

  Brightness=readFile(SPIFFS, "/Brightvalue.txt").toInt();
  //TEMP//setBrightness(Brightness);
  //TEMP//setcashbri(0); //-------------- reset
  //TEMP//setdebitbri(0);
  //TEMP//setcreditbri(0);


  // To print MAC ADDRESS
  Serial.print("ESP Board MAC Address:  ");
  Serial.println(WiFi.macAddress());

  //AsyncElegantOTA.begin(&server,OTA_username,OTA_password);    // Start ElegantOTA

  //server.begin();
  pinMode(CASH,OUTPUT);
  pinMode(CREDIT,OUTPUT);
  pinMode(DEBIT,OUTPUT);
  pinMode(dataPin,OUTPUT);
  pinMode(latchPin,OUTPUT);
  pinMode(clockPin,OUTPUT);
  pinMode(RESEND_POS,INPUT);
  pinMode(RED_LED_POS,OUTPUT);
  pinMode(WHITE_LED_POS,OUTPUT);
  pinMode(BLUE_LED_POS,OUTPUT);
  pinMode(resetssidpin, INPUT);

  digitalWrite(resetssidpin, HIGH);
  digitalWrite(RESEND_POS, LOW);
  digitalWrite(WHITE_LED_POS, LOW);
  digitalWrite(RED_LED_POS, LOW);

  //=========================================== MESH SETUP=================================================//
  /*
  mesh.setDebugMsgTypes(ERROR | STARTUP | DEBUG ); // set before init() so that you can see startup messages
  //mesh.setDebugMsgTypes( ERROR | STARTUP | DEBUG | MESH_STATUS | CONNECTION | SYNC | COMMUNICATION | GENERAL | MSG_TYPES | REMOTE ); // all types on
  uint8_t channel_num = 3;
  //mesh.init(MESH_PREFIX, MESH_PASSWORD, &userScheduler, MESH_PORT);
  //mesh.init( MESH_PREFIX, MESH_PASSWORD, &userScheduler, MESH_PORT,WIFI_AP_STA,channel_num );
  mesh.init( MESH_PREFIX, MESH_PASSWORD, &userScheduler, MESH_PORT, WIFI_AP_STA, 4, 0, 6);
  mesh.onReceive(&receivedCallback);
  mesh.onNewConnection(&newConnectionCallback);
  mesh.onChangedConnections(&changedConnectionCallback);
  mesh.onNodeTimeAdjusted(&nodeTimeAdjustedCallback);
  mesh.onNodeDelayReceived(&delayReceivedCallback);
  mesh.onDroppedConnection(&droppedConnectionCallback);
  userScheduler.addTask(taskSendMessage);
  taskSendMessage.enable();


  

  Serial.println("My Mesh IP is " + IPAddress(mesh.getAPIP()).toString());
  Serial.println(mesh.getNodeId());
  
  Serial.print(F("MeshSSID is = "));
  Serial.println(meshssid);

  Serial.print(F("MeshPASSWORD is = "));
  Serial.println(meshpassword);

  Serial.print(F("MeshPORT is = "));
  Serial.println(meshport);*/
  //=========================================== Intermediator setup ======================================//
  Serial2.setTimeout(5);
  pinMode(setHC, OUTPUT);
  MASTER_channel_RF = readFile(SPIFFS, "/master_RF_channel_num.txt").toInt();
  iport_s();  //INITIALISATION
  delayStart = millis();   // start delay
  delayRunning = true; // not finished yet
  
  //=========================================== TIMER SETUP ============================================//
  flashing=readFile(SPIFFS, "/flashing.txt").toInt();
  flash_time=readFile(SPIFFS, "/flash_time.txt").toInt();
  Serial.println("flashing = ");
  Serial.println(flashing);

  //=========================================== pos timer setup ============================================//
  //-------------------------------- set timers ------

  timerupdate.setTimeout(1 * 5 * 1000UL);
  timerreset.setTimeout(1 * 1 * 1000UL);
  timerbut.setTimeout(1 * .4 * 1000UL);
  resettimer2.setTimeout(1 * 6 * 1000UL);
  flash_timer.setTimeout(1 * 4 * 1000UL);
  timerrecount.setTimeout(1 * 1 * 1000UL);
  hmitimer.setTimeout(1 * 2 * 1000UL);
  hmitimer.restart();
  gill_update.setTimeout(1 * 1.5 * 1000UL);
  
  //===================== initial setup in startup =====================================================//
  num_of_groups=readFile(SPIFFS, "/num_of_groups.txt").toInt(); //temp of for just testing turn it on
  group_type=readFile(SPIFFS, "/group_type.txt").toInt();
  Serial.print("num_of_groups = ");
  Serial.println(num_of_groups);
  led_blink=readFile(SPIFFS, "/blinking_status.txt").toInt();

  G_NAME[1] = readFile(SPIFFS, "/G1_NAME.txt");
  G_NAME[2] = readFile(SPIFFS, "/G2_NAME.txt");
  G_NAME[3] = readFile(SPIFFS, "/G3_NAME.txt");
  G_NAME[4] = readFile(SPIFFS, "/G4_NAME.txt");
  G_NAME[5] = readFile(SPIFFS, "/G5_NAME.txt");
  G_NAME[6] = readFile(SPIFFS, "/G6_NAME.txt");
  G_NAME[7] = readFile(SPIFFS, "/G7_NAME.txt");
  G_NAME[8] = readFile(SPIFFS, "/G8_NAME.txt");
  G_NAME[9] = readFile(SPIFFS, "/G9_NAME.txt");
  G_NAME[10] = readFile(SPIFFS, "/G10_NAME.txt");
  G_NAME[11] = readFile(SPIFFS, "/G11_NAME.txt");
  G_NAME[12] = readFile(SPIFFS, "/G12_NAME.txt");
  G_NAME[13] = readFile(SPIFFS, "/G13_NAME.txt");
  G_NAME[14] = readFile(SPIFFS, "/G14_NAME.txt");
  G_NAME[15] = readFile(SPIFFS, "/G15_NAME.txt");
  G_NAME[16] = readFile(SPIFFS, "/G16_NAME.txt");
  //Serial.println(led_blink);
//======================= GRADE CHANGE LOGIC check  =========================//
  if(((group_type == 1) || (flashing == 1)) && (num_of_groups == 3))
  {
    grade_check = 1;
    Serial.print("grade change logic = ");
    Serial.println(grade_check);
  }

  //======================= pos initialisation ===============================================//
  digitalWrite(RED_LED_POS,HIGH);
  //--------- scan boards initialise----------------------//
        String inputMessage5;
        inputMessage5 = "0";
        writeFile(SPIFFS, "/MAXnodesize.txt", inputMessage5.c_str());
        MAXnodesize = 0;
  //---------- sleep mode init --------------//

  for (int y = 1; y < 96; y+=2) { //cash
    hmi_sleep_digit[y] = 10;
    }
}

void loop() {
  //userScheduler.execute(); // it will run mesh scheduler as well
  //mesh.update();
  if (timerreset.onExpired()) {
    //resend();//temp
  }
  /*
  if (digitalRead(RESEND_POS) == HIGH) {
    timerreset.restart();
  }*/
  //temp//attachInterrupt(RESEND_POS, resend_data, FALLING);

  switch (POS_setup_enable) {
    case 1:
        //Serial.println("Choice is 1");
        data_recieve_app(); //brightness and values recieving from app
        break;
    case 2:
        //Serial.println("Choice is 2");
        HMI_INTERFACE();  //check gilbarco serial using gilbarco commands
        recvWithStartEndMarkers();  //check verifone serial receive using veriphone commands
        break;
    case 3:
        //Serial.println("Choice is 3");
        HMI_INTERFACE();  //check gilbarco serial using gilbarco commands
        Gillbarco();  //temp
        break;
    case 4:
        //Serial.println("Choice is 4");
        HMI_INTERFACE();  //check gilbarco serial using gilbarco commands
        break;
    default:
        //Serial.println("Choice other than 1, 2 and 3");
        data_recieve_app(); //brightness and values recieving from app
        break;
    }
  if (gill_update.isExpired()){
    Gillbarco_data_update();
  }
  //HMI_INTERFACE();  //check gilbarco serial using gilbarco commands
  //recvWithStartEndMarkers();  //check verifone serial receive using veriphone commands
  //Gillbarco();  //temp
  //setup_led_blink();  //led blink to recognise app configuring led_status
  data_transmit_rf(); // data transmit values of price and cdc data to device using RF device
/*
  if (hmitimer.onExpired()) {
    hmitimer.restart();
    hmicount = hmicount+1;
    Serial.print("timer = ");
    Serial.println(hmicount);
    iport_s();
  Serial.println("sync MSG SENDING FROM LOOP");
  }*/
  unsigned long currentMillis = millis();
 
  if((currentMillis - previousMillis )  >= OnTime)
  {
   // sendMessage();
    send_times++;
    led_status_send = !led_status_send;
    previousMillis = currentMillis;  // Remember the time
  }
    //--------------------------------  RESET SIDD and PASSWORD Function for digit -----------------------------------

  if (DRRB == 0)
  {
    if (digitalRead(resetssidpin) == LOW && timerbut.isExpired())
    {
      //timerbut.restart();
      //timerrecount.restart();
      //resetcount++;
      //Serial.println(resetcount);
    }
  }

  if (resetcount >= 15)
  {
    Serial.println("got recount 15 to start reset");
    resetssidpassport();
    resetcount = 0;
  }

  if (timerrecount.onExpired())
  {
    resetcount = 0;
    Serial.print("Reset Count has Expierd");
    Serial.println(resetcount);
  }
  
  if(hmi_serial_recieved == true)
  {
    hmi_serial_recieve(); //recieve data
    hmi_serial_recieved = false;
  }
  if (flash_timer.isExpired())
    {
      if(device_flash == 1)
      {
        flash_timer.restart();
        Serial.println(" selected board blink = " );
        String selected_blink = "FLASH," + String(setup_node_id_mac) + ",";
        //mesh.sendBroadcast(selected_blink);
        //taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
      } 
    }

  //--------------------- nodes manage------------------//
  if(old_node_size != connected_node_size)
  {
    Serial.println(" node size changed take action for scan boards " );
    node_change_update();
    old_node_size = connected_node_size;
  }
  // ----------------- recieving commands from RF REMOTE AND RF POS ---------------//
  while (Serial2.available() > 0) 
  {
    
    int input = Serial2.parseInt();
    //String input2 = Serial2.readString();
    //int input;
    //Serial.println(input2);
    //Serial.println("RF REC");
    //if ((input > 0) && (input >= 28416) && (input <= 30463))  //ONLY CHANNEL DATA RECIEVE FILTER
    if (input > 0)
    {
      int cmd = input & 7;
      int value = (input & 255) >> 3;
      currentpos = input >> 8;
      Serial.println(input);

      if (currentpos == 112){  // READ RF CHANNEL  
        Serial.print("got 112 POS RF CHANNEL RECIEVED = ");
        Serial.println(value);
        if(cmd == 1)  // to save the current blinking master channel
        {
          Serial.println("POS REC RF CHANNEL saved = ");
          Serial.println(value);
          hmi.HMT_WriteVPN16(0x00087306,value);
          hmi.HMT_WirteVPString(0x00002400, &SUCCESSFULL[0]);
        }    
      }
      if (currentpos == 111) 
      {  // REMOTE AND MASTER RF CHANNEL CHANGE
        
        Serial.println("got 111 REMOTE RF CHANNEL RECIEVED");
        Serial.println(value);
        if(cmd == 1)  // to save the current blinking master channel
        {
          Serial.println("REMOTE REC RF CHANNEL saved = ");
          Serial.println(value);
          hmi.HMT_WriteVPN16(0x00087302,value);
          hmi.HMT_WirteVPString(0x00002380, &SUCCESSFULL[0]);
        }   
      }
    }
  }
  Serial2.flush();  //clear the serial buffer for unwanted inputs


}